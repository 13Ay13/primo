<script>

  import { firestore, collections } from '../_store.js'
  import _ from 'lodash'

  import {processStyles,getUniqueId,getEmptyData,convertFieldsToData,parseHandlebars,scrambleIds,updateInstancesInContent} from 'utils'
  import { get } from 'svelte/store'

  import {domainInfo, pageData, tailwind, user} from '@stores/data'

</script>

<script context="module">
 
  let domainsCollection
  let subdomainsCollection
  let usersCollection
  collections.subscribe(store => {
    if (store) {
      subdomainsCollection = store.subdomains
      domainsCollection = store.domains
      usersCollection = store.users
    }
  })

  export async function registerSubdomain(subdomain) {
    const {email} = get(user)
    const subdomainRef = subdomainsCollection.doc(subdomain);
    subdomainRef.set({ active: true })
    await subdomainRef.collection('users')
      .doc(email)
      .set({
        role: 'developer',
        admin: true
      })

    const data = await getEmptyData({ title: 'Primo Page', url: 'index' })

    await subdomainRef.collection('pages')
      .doc('index')
      .set(data)
  }

  export async function checkIfSubdomainExists(subdomain) {
    const subdomainRef = subdomainsCollection.doc(subdomain);
    const subdomainSnapshot = await subdomainRef.get()
    return subdomainSnapshot.exists
  }

  export async function deregisterSubdomain(subdomain) {
    const {email} = get(user)
    const subdomainRef = subdomainsCollection.doc(subdomain);
    subdomainRef.delete()

    await subdomainRef.collection('pages').doc('index').delete()
  }

  export async function registerDomain(domain) {
    const {email} = get(user)
    const domainRef = domainsCollection.doc(domain);
    domainRef.set({ active: true })
    await domainRef.collection('users')
      .doc(email)
      .set({
        role: 'developer',
        admin: true
      })

    const data = await getEmptyData()

    await domainRef.collection('pages')
      .doc('index')
      .set(data)
  }

  export async function addSiteCollaborator(domain, email, role) {
    try {
      const domainRef = subdomainsCollection.doc(domain);
      await domainRef.collection('users')
        .doc(email)
        .set({
          role,
          admin: false,
          active: false
        })
      return true
    } catch(e) {
      console.error(e)
      return false
    }
  }

  export async function getPageData(pageId, subdomain) {
    const subdomainRef = subdomainsCollection.doc(subdomain)
    const pageSnapshot = await subdomainRef.collection('pages').doc(pageId).get()
    return pageSnapshot.data()
  }

  export async function getSiteData(subdomain) {
    const subdomainSnapshot = await subdomainsCollection.doc(subdomain).get()
    return subdomainSnapshot.data()
  }

  export async function getAllSymbols(subdomain) {
    const subdomainRef = subdomainsCollection.doc(subdomain)
    const componentCollection = await subdomainRef.collection('components').get()
    return componentCollection.docs.map(c => c.data())
  }

  export async function getAllData(pageId, subdomain) {
    const subdomainRef = subdomainsCollection.doc(subdomain)
    const pageRef = subdomainRef.collection('pages').doc(pageId)

    const [ page, site, symbols ] = await Promise.all([
      getPageData(pageId, subdomain), 
      getSiteData(subdomain),
      getAllSymbols(subdomain)
    ])

    return {
      page,
      site,
      symbols
    }
  }

  export async function acceptInvitation(domain, email, role) {
    try {
      const domainRef = subdomainsCollection.doc(domain);
      await domainRef.collection('users')
        .doc(email)
        .update({
          active: true
        })

      const userRef = usersCollection.doc(email)
      await userRef.collection('subdomains').doc(domain)
        .set({
          registration: null,
          role
        })

      return true
    } catch(e) {
      console.error(e)
      return false
    }
  }

  export async function unregisterDomain(domain) {
    if (domain !== 'primo.press') {
      console.log('Ungregistering ', domain)
      const domainRef = domainsCollection.doc(domain);
      domainRef.delete()
    }
  }

  export async function getPagesInSubdomain() {
    const subdomainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    const pagesCollection = await subdomainRef.collection('pages').get()
    return pagesCollection.docs.map(p => p.data())
  }

  export async function createPage(newPage, duplicate = false) {
    const domainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    const newPageRef = domainRef.collection('pages').doc(newPage.url)
    const newPageSnapshot = await newPageRef.get();

    if (!newPageSnapshot.exists) {
      let newData
      const currentpageRef = domainRef.collection('pages').doc(get(domainInfo).page)
      if (duplicate) {
        const currentPageSnapshot = await currentpageRef.get()
        newData = await duplicatePage(currentPageSnapshot.data(), newPage)

      } else {
        newData = await getEmptyData(newPage)  
      }
      await newPageRef.set(newData)
      return newData
      console.log('Created new page')
    } else {
      console.error('Page already exists')
      alert('Page already exists')
    }

  }

  export async function duplicatePage(pageData, newPage) {
    let newPageData = _.cloneDeep(pageData)
    const [ newContent, IDmap ] = scrambleIds(pageData.content)
    newPageData.content = newContent
    newPageData.settings.identity.title = newPage.title
    newPageData.settings.identity.url = newPage.url

    // Replace all the old IDs in the page styles with the new IDs
    let rawPageStyles = newPageData.settings.globalStyles.uncompiled
    let finalPageStyles = newPageData.settings.globalStyles.compiled
    IDmap.forEach(([ oldID, newID ]) => {
      newPageData.settings.globalStyles.uncompiled = rawPageStyles.replace(new RegExp(oldID, 'g'), newID);
      newPageData.settings.globalStyles.compiled = finalPageStyles.replace(new RegExp(oldID, 'g'), newID);
    })

    // Replace all the old IDs in the components 
    IDmap.forEach(([ oldID, newID ]) => {
      newPageData.content = newPageData.content.map(section => ({
        ...section,
        columns: section.columns.map(column => ({
          ...column,
          rows: column.rows.map(row => row.type === 'component' ? ({
            ...row,
            value: {
              ...row.value,
              raw: {
                ...row.value.raw,
                css: row.value.raw.css.replace(new RegExp(oldID, 'g'), newID)
              },
              final: {
                ...row.value.final,
                css: row.value.final.css.replace(new RegExp(oldID, 'g'), newID)
              }
            }
          }) : row)
        }))
      }))
    })

    return newPageData
  }

  export async function checkIfUrlTaken(url) {
    let domainRef = domainsCollection.doc(get(domainInfo).domainName);
    const pageSnapshot = await domainRef.collection('pages').doc(url).get()
    return pageSnapshot.exists
  }

  export async function setPagePassword(password) {
    const domainRef = domainsCollection.doc(get(domainInfo).domainName)
    const pageRef = domainRef.collection('pages').doc(get(domainInfo).page)
    pageRef.update({
      hasPassword: true
    })
    const secretRef = await domainRef.collection('secrets').doc(get(domainInfo).page)
    secretRef.set({ password })
  }

  export async function setPage(newData, domain = get(domainInfo).domainName, pageId = get(domainInfo).page) {
    const domainRef = domainsCollection.doc(domain)
    const pageRef = domainRef.collection('pages').doc(pageId)
    await pageRef.set({
      ...newData
    })
  }

  export async function getDomainData() {
    const domainSnapshot = await subdomainsCollection.doc(get(domainInfo).domainName).get()
    return domainSnapshot.data()
  }

  export async function setSubdomainRepo(repo) {
    const subdomainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    await subdomainRef.update({ repo })
  }

  export async function getAllPages(exclude = null) {
    const site = get(domainInfo).domainName
    const subdomainRef = subdomainsCollection.doc(site)
    const pagesSnapshot = await subdomainRef.collection('pages').get()
    return pagesSnapshot.docs.filter(p => p.id !== exclude).map(p => p.data())
  }

  export async function saveAllPages(pages) {
    const site = get(domainInfo).domainName
    const subdomainRef = subdomainsCollection.doc(site)
    await Promise.all(pages.map(async page => {
      const pageRef = subdomainRef.collection('pages').doc(page.settings.identity.url)
      await pageRef.set(page)
    }))
  }

  export async function saveToSite(newData) {
    console.log('Saving to Site', newData)
    const site = get(domainInfo).domainName
    const subdomainRef = subdomainsCollection.doc(site)
    await subdomainRef.update({
      ...newData
    })
  }

  export async function updatePage(newData, domain = get(domainInfo).domainName, pageId = get(domainInfo).page) {
    console.log('Saving to DB', domain+'/'+pageId, newData)
    const subdomainRef = subdomainsCollection.doc(domain)
    const pageRef = subdomainRef.collection('pages').doc(pageId)
    await pageRef.update({
      ...newData
    })
  }

  export async function changePageUrl(identity) {

    const id = identity.url

    const subdomainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    const newPageRef = subdomainRef.collection('pages').doc(id)

    let newData = get(pageData)
    newData.settings.identity = identity
    await newPageRef.set(newData);

    deletePage(get(domainInfo).page)
    domainInfo.save({page: id})

  }

  export async function deleteComponentFromDomain(componentId) {
    console.log('Deleting component from domain', componentId)
    const domainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    await domainRef.collection('components').doc(componentId).delete()
  }

  export async function updateInstancesInDomain(symbol) {
    // Goes through all the content in the domain and updates any components within tied to the library symbol
    const domainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    const pagesSnapshot = await domainRef.collection('pages').get()

    await Promise.all(pagesSnapshot.docs.map(async (page) => {
      const {content} = page.data()
      const pageRows = _.flatMapDeep(content, section => section.columns.map(column => column.rows))
      const containsComponent = _.some(pageRows, ['symbolID', symbol.id])
      if (containsComponent) {
        // Go through every row in the page to update relevant components
        await domainRef.collection('pages').doc(page.id).update({
          content: await updateInstancesInContent(symbol, content)
        })
      }
    }));

  }

  export async function saveSymbolToDomain(component) {
    const domainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    const componentsRef = domainRef.collection('components').doc(component.id)
    await componentsRef.set(component)
    console.log(`Component saved to ${get(domainInfo).domainName}`, component)
  }

  export async function getSymbol(symbolID) {
    const domainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    const componentRef = await domainRef.collection('components').doc(symbolID).get()
    return componentRef.data()
  }

  export async function getComponents() {
    const domainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    const componentCollection = await domainRef.collection('components').get()
    return componentCollection.docs.map(c => c.data()) // show newest to oldest
  }

  export async function deletePage(pageId) {
    const subdomainRef = subdomainsCollection.doc(get(domainInfo).domainName)
    if (pageId !== 'index') {
      try {
        await subdomainRef.collection('pages').doc(pageId).delete()
        console.log(`Document ${ pageId } deleted`)
      } catch(e) {
        console.error("Error removing document: ", e);
      }
    } else {
      alert('Index page cannot be deleted')
    }
  }


</script>