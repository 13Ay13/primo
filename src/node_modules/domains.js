import axios from 'axios'
import { domainInfo, user } from '@stores/data'
import { get } from 'svelte/store'
import { registerDomain, unregisterDomain } from '@fb/firestore/domains'
import { getUserDomains, addDomainToUser, removeDomainFromUser, setUserStripeId, getUserStripeId, addSubscriptionToUser, removeSubscriptionFromUser } from '@fb/firestore/users'
// import { registerDomain, addDomainToUser, getUserDomains, unregisterDomain, removeDomainFromUser, setUserStripeId, getUserStripeId, addSubscriptionToUser, removeSubscriptionFromUser } from 'database'
import { Domain } from 'constructs'
import {notify} from 'utils'
import _ from 'lodash'

const functionsEndpoint = (endpoint) => get(domainInfo).onDev ? `http://localhost:9000/primo-d4041/us-central1/primo/${endpoint}` : `https://us-central1-primo-d4041.cloudfunctions.net/primo/${endpoint}`

const ax = {
  async post(endpoint, params) {
    try {
      let { data } = await axios.post(functionsEndpoint(endpoint), params)
      return data
    } catch(e) {
      console.error(e)
      return e
    }
  },
  async get(endpoint) {
    try {
      return await axios.get(functionsEndpoint(endpoint))
    } catch(e) {
      console.error(e)
      return e
    }
  }
}


export async function createNewSubscription(payData, hostname) {

  let stripeId = await getUserStripeId()

  let { subscription, customerId } = await ax.post('stripe/new-subscription', {
    customerId: stripeId,
    email: get(user).email,
    payment_method: payData.paymentMethod.id
  })  

  let paymentSuccessful = subscription.latest_invoice.paid

  if (paymentSuccessful) {
    notify({
      title: 'Payment successful',
      message: hostname
    }, 'stripe')
    if (!stripeId) {
      setUserStripeId(customerId)
    }
    addSubscriptionToUser(subscription, hostname)
  } else {
    notify({
      title: 'Payment unsuccessful',
      message: hostname
    }, 'stripe')
  }
  
  return paymentSuccessful
}

export async function addNewDomain(domainName) {
  let domainData = await ax.post('register-domain', { domain: domainName })
  await addDomainToUser(domainData) // should come first, for security reasons
  registerDomain(domainName)
  return domainData
}

export async function getUpdatedDomains() {
  let userDomains = await getUserDomains()
  let updatedUserDomains = []
  if (userDomains.length > 0 && userDomains[0]['data']['registration']) {
    userDomains = userDomains.map(d => d.data.registration)
    const hostnames = userDomains.map(d => d.hostname)
    let fetchedDomains = await ax.post('domain-status', { hostnames })
    updatedUserDomains = userDomains.map((domain) => {
      const updatedDomain = _.find(fetchedDomains, ['hostname', domain.hostname])
      return updatedDomain || domain
    })
    
    // update domains in firebase if new data exists
    updatedUserDomains.forEach((updatedDomain) => {
      const {hostname,status} = updatedDomain
      const existingDomain = _.find(userDomains, d => d.hostname === hostname)
      if (status !== existingDomain.status) {
        addDomainToUser(updatedDomain)
      }
    })
    let parsedUserDomains = updatedUserDomains.map(d => Domain(d))
    return parsedUserDomains.sort((a, b) => new Date(a.created) - new Date(b.created)) // oldest to newest
  } else if (userDomains.length > 0) {
    // handle domains for collaborators
    return userDomains.map(d => d.id)
  } else {
    return userDomains
  }

}

export async function deleteDomain(domain) {
  await unregisterDomain(domain) 
  await removeDomainFromUser(domain)
  await ax.post('unregister-domain', { domain })

  let subscriptionId = await removeSubscriptionFromUser(domain);
  let success = await ax.post('stripe/unsubscribe', { subscriptionId })
  return success
}




