import { writable, readable, derived, get } from 'svelte/store';
import {saveToSite,getAllPages,saveAllPages,getComponents,saveSymbolToDomain} from '@fb/firestore/domains'
import { tailwindConfig, pageStyles } from 'const'
import {hydrateAllComponents,hydrateComponent,getUniqueId} from 'utils'

import {content,domainInfo} from '@stores/data'

const store = writable({
  pages: [
    {
      id: getUniqueId(),
      title: 'New Page',
      content: [
        {
          id: getUniqueId(),
          width: 'contained',
          columns: [
            {
              id: getUniqueId(),
              size: 'w-full',
              rows: [
                {
                  id: getUniqueId(),
                  type: 'content',
                  value: {
                    html: '<p>some simple content</p>'
                  }
                }
              ]
            }
          ]
        }
      ],
      dependencies: {
        headEmbed : '',
        libraries: [],
        // customScripts: [],
      },
      settings: {
        globalStyles: {
          uncompiled: '',
          compiled: '',
          tailwindConfig: '{  theme: {    container: {      center: true    }  },  variants: {}}'
        },
        javascript: '',
        identity : {
          title: '', 
          url: '',
          description: ''
        }
      }
    },
  ],
  data: {
    navItems: []
  },
  styles: {
    raw: pageStyles,
    final: '',
    tailwind: tailwindConfig
  },
  symbols: [
    {
      height: '',
      id: '',
      title: '',
      type: '',
      value: {
        raw: {
          html: '<h1>Default</h1>',
          css: '',
          js: '',
          fields: []
        },
        final: {
          html: '<h1>Default</h1>',
          css: '',
          js: '',
        }
      }
    }
  ],
})

export default {
  subscribe: store.subscribe, 
  update: store.update,
  pages: {
    add: (page) => {
      store.update(s => ({
        ...s, 
        pages: [ ...s.pages, page ]
      }))
    },
    remove: (pageId) => {
      store.update(s => ({
        ...s,
        pages: s.pages.filter(page => page.id !== pageId)
      }))
    },
    modify: (page) => {
      store.update(s => ({
        ...s,
        pages: s.pages.map(p => p.id === page.id ? page : p)
      }))
    }
  },
  saveNav: async (navItems) => {
    const { pageId } = get(domainInfo)
    await saveSiteData({ navItems })
    await Promise.all([ hydrateComponentLibrary(), hydratePageContent(), hydrateSitePagesContent(pageId)])
  },
  saveStyles: async (styles) => {
    store.update(s => ({ ...s, styles }))
  },
  savePageSettings: (settings) => {
    const { pageId } = get(domainInfo)
    store.update(s => ({ 
      ...s,  
      pages: s.pages.map(page => page.id === pageId ? ({
          ...page,
          settings
      }) : page)
    }))
  },
  save: (data = {}) => {
    store.update(s => ({ ...s, ...data }))
    // saveToSite(data)
  },
  saveContent: (content) => {
    const { page:pageId } = get(domainInfo)
    store.update(s => ({ 
      ...s,  
      pages: s.pages.map(page => page.id === pageId ? ({
          ...page,
          content
      }) : page)
    }))
  }
};


// REDUCERS
async function saveSiteData(data) {
  store.update(s => ({ ...s, data }))
}

async function hydratePageContent() {
  const updatedContent = await hydrateAllComponents(get(content))
  content.set(updatedContent)
}

async function hydrateSitePagesContent(exclude = null) {
  const updatedPages = await hydrateSiteComponents(exclude)
  await saveAllPages(updatedPages)
}

async function hydrateComponentLibrary() {
  const components = await getComponents()
  const hydratedComponents = await Promise.all( components.map(async component => await hydrateComponent(component)) )
  await Promise.all([ hydratedComponents.map(async component => saveSymbolToDomain(component)) ])
}



// HELPERS
async function hydrateSiteComponents(exclude = null) {
  const pages = await getAllPages()
  const updatedPages = await Promise.all(pages.filter(page => page.settings.identity.url !== exclude).map(async page => ({
    ...page,
    content: await hydrateAllComponents(page.content)
  })))
  return updatedPages
}