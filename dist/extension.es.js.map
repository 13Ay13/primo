{"version":3,"file":"extension.es.js","sources":["../node_modules/@emmetio/codemirror-plugin/dist/extension.es.js"],"sourcesContent":["const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace$1)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote$1(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote$1(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote$1(token) || isOperator(token) || isWhiteSpace$1(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote$1(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace$1(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, ctx) {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace() {\n        return ' ';\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                textInserted = true;\n                const value = Array.isArray(options.text)\n                    ? (pos != null ? options.text[pos] : options.text.join('\\n'))\n                    : options.text;\n                return value != null ? value : '';\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.text.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote$1(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nfunction tokenize$1(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken$1(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator$1(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken$1(scanner, short) {\n    return field$1(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket$1(scanner)\n        || operator$1(scanner)\n        || whiteSpace$1(scanner)\n        || literal$2(scanner, short);\n}\nfunction field$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder$1(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder$1(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$1(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal$2(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral$1);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral$1 : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral$1);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral$1(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral$1(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral$1(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket$1(scanner) {\n    const ch = scanner.peek();\n    if (isBracket$1(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator$1(scanner) {\n    const op = operatorType$1(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType$1(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket$1(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral$1(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last$1(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral$1(scanner, start, end));\n    }\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner$1(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$1(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable$1(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$1(scanner, test) {\n    if (test(peek$1(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error$1(scanner, message, token = peek$1(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner$1(tokens);\n    const result = [];\n    let property;\n    while (readable$1(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume$1(scanner, isSiblingOperator$1)) {\n            throw error$1(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek$1(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume$1(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume$1(scanner, isWhiteSpace$2);\n    }\n    while (readable$1(scanner)) {\n        if (consume$1(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume$1(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable$1(scanner)) {\n        token = peek$1(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace$2(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume$1(scanner, isOpenBracket$1)) {\n        const args = [];\n        let value;\n        while (readable$1(scanner) && !consume$1(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume$1(scanner, isWhiteSpace$2) && !consume$1(scanner, isArgumentDelimiter)) {\n                throw error$1(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket$1(token) {\n    return isBracket$1$1(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket$1$1(token, false);\n}\nfunction isWhiteSpace$2(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator$1(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator$1(token) {\n    return isOperator$1(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator$1(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator$1(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator$1(token, \":\" /* PropertyDelimiter */)\n        || isOperator$1(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize$1(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nconst defaultConfig = {\n    mark: true,\n    preview: true,\n    autoRenameTags: true,\n    markTagPairs: true,\n    previewOpenTag: false,\n    attributeQuotes: 'double',\n    markupStyle: 'html',\n    comments: false,\n    commentsTemplate: '<!-- /[#ID][.CLASS] -->',\n    bem: false\n};\nfunction getEmmetConfig(editor, opt) {\n    if (!opt) {\n        // @ts-ignore Bypass limited options, defined in typings\n        opt = editor.getOption('emmet');\n    }\n    return Object.assign(Object.assign({}, defaultConfig), opt);\n}\n\nconst defaultOptions = {\n    xml: false,\n    allTokens: false,\n    special: {\n        style: null,\n        script: ['', 'text/javascript', 'application/x-javascript', 'javascript', 'typescript', 'ts', 'coffee', 'coffeescript']\n    },\n    empty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr', 'col', 'embed', 'input', 'param', 'source', 'track']\n};\n/** Options for `Scanner` utils */\nconst opt = { throws: false };\nfunction createOptions(options = {}) {\n    return Object.assign(Object.assign({}, defaultOptions), options);\n}\n/**\n * Converts given string into array of character codes\n */\nfunction toCharCodes(str) {\n    return str.split('').map(ch => ch.charCodeAt(0));\n}\n/**\n * Consumes array of character codes from given scanner\n */\nfunction consumeArray(scanner, codes) {\n    const start = scanner.pos;\n    for (let i = 0; i < codes.length; i++) {\n        if (!scanner.eat(codes[i])) {\n            scanner.pos = start;\n            return false;\n        }\n    }\n    scanner.start = start;\n    return true;\n}\n/**\n * Consumes section from given string which starts with `open` character codes\n * and ends with `close` character codes\n * @return Returns `true` if section was consumed\n */\nfunction consumeSection(scanner, open, close, allowUnclosed) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, open)) {\n        // consumed `<!--`, read next until we find ending part or reach the end of input\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, close)) {\n                scanner.start = start;\n                return true;\n            }\n            scanner.pos++;\n        }\n        // unclosed section is allowed\n        if (allowUnclosed) {\n            scanner.start = start;\n            return true;\n        }\n        scanner.pos = start;\n        return false;\n    }\n    // unable to find section, revert to initial position\n    scanner.pos = start;\n    return false;\n}\n/**\n * Check if given character can be used as a start of tag name or attribute\n */\nfunction nameStartChar(ch) {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameStartChar\n    return isAlpha(ch) || ch === 58 /* Colon */ || ch === 95 /* Underscore */\n        || (ch >= 0xC0 && ch <= 0xD6)\n        || (ch >= 0xD8 && ch <= 0xF6)\n        || (ch >= 0xF8 && ch <= 0x2FF)\n        || (ch >= 0x370 && ch <= 0x37D)\n        || (ch >= 0x37F && ch <= 0x1FFF);\n}\n/**\n * Check if given character can be used in a tag or attribute name\n */\nfunction nameChar(ch) {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameChar\n    return nameStartChar(ch) || ch === 45 /* Dash */ || ch === 46 /* Dot */ || isNumber(ch)\n        || ch === 0xB7\n        || (ch >= 0x0300 && ch <= 0x036F);\n}\n/**\n * Consumes identifier from given scanner\n */\nfunction ident(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(nameStartChar)) {\n        scanner.eatWhile(nameChar);\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Check if given code is tag terminator\n */\nfunction isTerminator(code) {\n    return code === 62 /* RightAngle */ || code === 47 /* Slash */;\n}\n/**\n * Check if given character code is valid unquoted value\n */\nfunction isUnquoted(code) {\n    return !isNaN(code) && !isQuote(code) && !isSpace(code) && !isTerminator(code);\n}\n/**\n * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded\n * quoted values\n * @return `true` if paired token was consumed\n */\nfunction consumePaired(scanner) {\n    return eatPair(scanner, 60 /* LeftAngle */, 62 /* RightAngle */, opt)\n        || eatPair(scanner, 40 /* LeftRound */, 41 /* RightRound */, opt)\n        || eatPair(scanner, 91 /* LeftSquare */, 93 /* RightSquare */, opt)\n        || eatPair(scanner, 123 /* LeftCurly */, 125 /* RightCurly */, opt);\n}\n/**\n * Returns unquoted value of given string\n */\nfunction getUnquotedValue(value) {\n    // Trim quotes\n    if (isQuote(value.charCodeAt(0))) {\n        value = value.slice(1);\n    }\n    if (isQuote(value.charCodeAt(value.length - 1))) {\n        value = value.slice(0, -1);\n    }\n    return value;\n}\n\n/**\n * Parses given string as list of HTML attributes.\n * @param src A fragment to parse. If `name` argument is provided, it must be an\n * opening tag (`<a foo=\"bar\">`), otherwise it should be a fragment between element\n * name and tag closing angle (`foo=\"bar\"`)\n * @param name Tag name\n */\nfunction attributes(src, name) {\n    const result = [];\n    let start = 0;\n    let end = src.length;\n    if (name) {\n        start = name.length + 1;\n        end -= src.slice(-2) === '/>' ? 2 : 1;\n    }\n    const scanner = new Scanner(src, start, end);\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            const token = {\n                name: scanner.current(),\n                nameStart: scanner.start,\n                nameEnd: scanner.pos\n            };\n            if (scanner.eat(61 /* Equals */) && attributeValue(scanner)) {\n                token.value = scanner.current();\n                token.valueStart = scanner.start;\n                token.valueEnd = scanner.pos;\n            }\n            result.push(token);\n        }\n        else {\n            // Do not break on invalid attributes: we are not validating parser\n            scanner.pos++;\n        }\n    }\n    return result;\n}\n/**\n * Consumes attribute name from given scanner context\n */\nfunction attributeName(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */) || scanner.eat(35 /* Hash */)) {\n        // Angular-style directives: `<section *ngIf=\"showSection\">`, `<video #movieplayer ...>`\n        ident(scanner);\n        scanner.start = start;\n        return true;\n    }\n    // Attribute name could be a regular name or expression:\n    // React-style – `<div {...props}>`\n    // Angular-style – `<div [ng-for]>` or `<div *ng-for>`\n    return consumePaired(scanner) || ident(scanner);\n}\n/**\n * Consumes attribute value\n */\nfunction attributeValue(scanner) {\n    // Supported attribute values are quoted, React-like expressions (`{foo}`)\n    // or unquoted literals\n    return eatQuoted(scanner, opt) || consumePaired(scanner) || unquoted(scanner);\n}\n/**\n * Returns clean (unquoted) value of `name` attribute\n */\nfunction getAttributeValue(attrs, name) {\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        if (attr.name === name) {\n            return attr.value && getUnquotedValue(attr.value);\n        }\n    }\n}\n/**\n * Consumes unquoted value\n */\nfunction unquoted(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isUnquoted)) {\n        scanner.start = start;\n        return true;\n    }\n}\n\nconst cdataOpen = toCharCodes('<![CDATA[');\nconst cdataClose = toCharCodes(']]>');\nconst commentOpen = toCharCodes('<!--');\nconst commentClose = toCharCodes('-->');\nconst piStart = toCharCodes('<?');\nconst piEnd = toCharCodes('?>');\nconst erbStart = toCharCodes('<%');\nconst erbEnd = toCharCodes('%>');\n/**\n * Performs fast scan of given source code: for each tag found it invokes callback\n * with tag name, its type (open, close, self-close) and range in original source.\n * Unlike regular scanner, fast scanner doesn’t provide info about attributes to\n * reduce object allocations hence increase performance.\n * If `callback` returns `false`, scanner stops parsing.\n * @param special List of “special” HTML tags which should be ignored. Most likely\n * it’s a \"script\" and \"style\" tags.\n */\nfunction scan(source, callback, options) {\n    const scanner = new Scanner(source);\n    const special = options ? options.special : null;\n    const allTokens = options ? options.allTokens : false;\n    let type;\n    let name;\n    let nameStart;\n    let nameEnd;\n    let nameCodes;\n    let found = false;\n    let piName = null;\n    while (!scanner.eof()) {\n        const start = scanner.pos;\n        if (cdata(scanner)) {\n            if (allTokens && callback('#cdata', 4 /* CData */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (comment(scanner)) {\n            if (allTokens && callback('#comment', 6 /* Comment */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (erb(scanner)) {\n            if (allTokens && callback('#erb', 7 /* ERB */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (piName = processingInstruction(scanner)) {\n            if (allTokens && callback(piName, 5 /* ProcessingInstruction */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (scanner.eat(60 /* LeftAngle */)) {\n            // Maybe a tag name?\n            type = scanner.eat(47 /* Slash */) ? 2 /* Close */ : 1 /* Open */;\n            nameStart = scanner.pos;\n            if (ident(scanner)) {\n                // Consumed tag name\n                nameEnd = scanner.pos;\n                if (type !== 2 /* Close */) {\n                    skipAttributes(scanner);\n                    scanner.eatWhile(isSpace);\n                    if (scanner.eat(47 /* Slash */)) {\n                        type = 3 /* SelfClose */;\n                    }\n                }\n                if (scanner.eat(62 /* RightAngle */)) {\n                    // Tag properly closed\n                    name = scanner.substring(nameStart, nameEnd);\n                    if (callback(name, type, start, scanner.pos) === false) {\n                        break;\n                    }\n                    if (type === 1 /* Open */ && special && isSpecial(special, name, source, start, scanner.pos)) {\n                        // Found opening tag of special element: we should skip\n                        // scanner contents until we find closing tag\n                        nameCodes = toCharCodes(name);\n                        found = false;\n                        while (!scanner.eof()) {\n                            if (consumeClosing(scanner, nameCodes)) {\n                                found = true;\n                                break;\n                            }\n                            scanner.pos++;\n                        }\n                        if (found && callback(name, 2 /* Close */, scanner.start, scanner.pos) === false) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n}\n/**\n * Skips attributes in current tag context\n */\nfunction skipAttributes(scanner) {\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            if (scanner.eat(61 /* Equals */)) {\n                attributeValue(scanner);\n            }\n        }\n        else if (isTerminator(scanner.peek())) {\n            break;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n}\n/**\n * Consumes closing tag with given name from scanner\n */\nfunction consumeClosing(scanner, name) {\n    const start = scanner.pos;\n    if (scanner.eat(60 /* LeftAngle */) && scanner.eat(47 /* Slash */) && consumeArray(scanner, name) && scanner.eat(62 /* RightAngle */)) {\n        scanner.start = start;\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes CDATA from given scanner\n */\nfunction cdata(scanner) {\n    return consumeSection(scanner, cdataOpen, cdataClose, true);\n}\n/**\n * Consumes comments from given scanner\n */\nfunction comment(scanner) {\n    return consumeSection(scanner, commentOpen, commentClose, true);\n}\n/**\n * Consumes processing instruction from given scanner. If consumed, returns\n * processing instruction name\n */\nfunction processingInstruction(scanner) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, piStart) && ident(scanner)) {\n        const name = scanner.current();\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, piEnd)) {\n                break;\n            }\n            eatQuoted(scanner) || scanner.pos++;\n        }\n        scanner.start = start;\n        return name;\n    }\n    scanner.pos = start;\n    return null;\n}\n/**\n * Consumes ERB-style entity: `<% ... %>` or `<%= ... %>`\n */\nfunction erb(scanner) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, erbStart)) {\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, erbEnd)) {\n                break;\n            }\n            eatQuoted(scanner) || scanner.pos++;\n        }\n        scanner.start = start;\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Check if given tag name should be considered as special\n */\nfunction isSpecial(special, name, source, start, end) {\n    if (name in special) {\n        const typeValues = special[name];\n        if (!Array.isArray(typeValues)) {\n            return true;\n        }\n        const attrs = attributes(source.substring(start + name.length + 1, end - 1));\n        return typeValues.includes(getAttributeValue(attrs, 'type') || '');\n    }\n    return false;\n}\n\n/**\n * Finds matched tag for given `pos` location in XML/HTML `source`\n */\nfunction match(source, pos, opt) {\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    let result = null;\n    scan(source, (name, type, start, end) => {\n        if (type === 1 /* Open */ && isSelfClose(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = 3 /* SelfClose */;\n        }\n        if (type === 1 /* Open */) {\n            // Allocate tag object from pool\n            stack.push(allocTag(pool, name, start, end));\n        }\n        else if (type === 3 /* SelfClose */) {\n            if (start < pos && pos < end) {\n                // Matched given self-closing tag\n                result = {\n                    name,\n                    attributes: getAttributes(source, start, end, name),\n                    open: [start, end]\n                };\n                return false;\n            }\n        }\n        else {\n            const tag = last$2(stack);\n            if (tag && tag.name === name) {\n                // Matching closing tag found\n                if (tag.start < pos && pos < end) {\n                    result = {\n                        name,\n                        attributes: getAttributes(source, tag.start, tag.end, name),\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    };\n                    return false;\n                }\n                else if (stack.length) {\n                    // Release tag object for further re-use\n                    releaseTag(pool, stack.pop());\n                }\n            }\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in outward direction\n */\nfunction balancedOutward(source, pos, opt) {\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    const result = [];\n    scan(source, (name, type, start, end) => {\n        if (type === 2 /* Close */) {\n            const tag = last$2(stack);\n            if (tag && tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.start < pos && pos < end) {\n                    result.push({\n                        name,\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    });\n                }\n                // Release tag object for further re-use\n                releaseTag(pool, stack.pop());\n            }\n        }\n        else if (type === 3 /* SelfClose */ || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag\n                result.push({ name, open: [start, end] });\n            }\n        }\n        else {\n            stack.push(allocTag(pool, name, start, end));\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in inward direction\n */\nfunction balancedInward(source, pos, opt) {\n    // Collecting tags for inward balancing is a bit trickier: we have to store\n    // first child of every matched tag until we find the one that matches given\n    // location\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    const result = [];\n    const alloc = (name, start, end) => {\n        if (pool.length) {\n            const tag = pool.pop();\n            tag.name = name;\n            tag.ranges.push(start, end);\n            return tag;\n        }\n        return { name, ranges: [start, end] };\n    };\n    const release = (tag) => {\n        tag.ranges.length = 0;\n        tag.firstChild = void 0;\n        pool.push(tag);\n    };\n    scan(source, (name, type, start, end) => {\n        if (type === 2 /* Close */) {\n            if (!stack.length) {\n                // Some sort of lone closing tag, ignore it\n                return;\n            }\n            let tag = last$2(stack);\n            if (tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.ranges[0] <= pos && pos <= end) {\n                    result.push({\n                        name,\n                        open: tag.ranges.slice(0, 2),\n                        close: [start, end]\n                    });\n                    while (tag.firstChild) {\n                        const child = tag.firstChild;\n                        const res = {\n                            name: child.name,\n                            open: child.ranges.slice(0, 2)\n                        };\n                        if (child.ranges.length > 2) {\n                            res.close = child.ranges.slice(2, 4);\n                        }\n                        result.push(res);\n                        release(tag);\n                        tag = child;\n                    }\n                    return false;\n                }\n                else {\n                    stack.pop();\n                    const parent = last$2(stack);\n                    if (parent && !parent.firstChild) {\n                        // No first child in parent node: store current tag\n                        tag.ranges.push(start, end);\n                        parent.firstChild = tag;\n                    }\n                    else {\n                        release(tag);\n                    }\n                }\n            }\n        }\n        else if (type === 3 /* SelfClose */ || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag, no need to look further\n                result.push({ name, open: [start, end] });\n                return false;\n            }\n            const parent = last$2(stack);\n            if (parent && !parent.firstChild) {\n                parent.firstChild = alloc(name, start, end);\n            }\n        }\n        else {\n            stack.push(alloc(name, start, end));\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\nfunction allocTag(pool, name, start, end) {\n    if (pool.length) {\n        const tag = pool.pop();\n        tag.name = name;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, start, end };\n}\nfunction releaseTag(pool, tag) {\n    pool.push(tag);\n}\n/**\n * Returns parsed attributes from given source\n */\nfunction getAttributes(source, start, end, name) {\n    const tokens = attributes(source.slice(start, end), name);\n    tokens.forEach(attr => {\n        attr.nameStart += start;\n        attr.nameEnd += start;\n        if (attr.value != null) {\n            attr.valueStart += start;\n            attr.valueEnd += start;\n        }\n    });\n    return tokens;\n}\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose(name, options) {\n    return !options.xml && options.empty.includes(name);\n}\nfunction last$2(arr) {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n\n/**\n * Performs fast scan of given stylesheet (CSS, LESS, SCSS) source code and runs\n * callback for each token and its range found. The goal of this parser is to quickly\n * determine document structure: selector, property, value and block end.\n * It doesn’t provide detailed info about CSS atoms like compound selectors,\n * operators, quoted string etc. to reduce memory allocations: this data can be\n * parsed later on demand.\n */\nfunction scan$1(source, callback) {\n    const scanner = new Scanner(source);\n    const state = {\n        start: -1,\n        end: -1,\n        propertyStart: -1,\n        propertyEnd: -1,\n        propertyDelimiter: -1,\n        expression: 0,\n    };\n    let blockEnd;\n    const notify = (type, delimiter = scanner.start, start = state.start, end = state.end) => {\n        return callback(type, start, end, delimiter) === false;\n    };\n    while (!scanner.eof()) {\n        if (comment$1(scanner) || whitespace(scanner)) {\n            continue;\n        }\n        scanner.start = scanner.pos;\n        if ((blockEnd = scanner.eat(125 /* RightCurly */)) || scanner.eat(59 /* Semicolon */)) {\n            // Block or property end\n            if (state.propertyStart !== -1) {\n                // We have pending property\n                if (notify(\"propertyName\" /* PropertyName */, state.propertyDelimiter, state.propertyStart, state.propertyEnd)) {\n                    return;\n                }\n                if (state.start === -1) {\n                    // Explicit property value state: emit empty value\n                    state.start = state.end = scanner.start;\n                }\n                if (notify(\"propertyValue\" /* PropertyValue */)) {\n                    return;\n                }\n            }\n            else if (state.start !== -1 && notify(\"propertyName\" /* PropertyName */)) {\n                // Flush consumed token\n                return;\n            }\n            if (blockEnd) {\n                state.start = scanner.start;\n                state.end = scanner.pos;\n                if (notify(\"blockEnd\" /* BlockEnd */)) {\n                    return;\n                }\n            }\n            reset(state);\n        }\n        else if (scanner.eat(123 /* LeftCurly */)) {\n            // Block start\n            if (state.start === -1 && state.propertyStart === -1) {\n                // No consumed selector, emit empty value as selector start\n                state.start = state.end = scanner.pos;\n            }\n            if (state.propertyStart !== -1) {\n                // Now we know that value that looks like property name-value pair\n                // was actually a selector\n                state.start = state.propertyStart;\n            }\n            if (notify(\"selector\" /* Selector */)) {\n                return;\n            }\n            reset(state);\n        }\n        else if (scanner.eat(58 /* Colon */) && !isKnownSelectorColon(scanner, state)) {\n            // Colon could be one of the following:\n            // — property delimiter: `foo: bar`, must be in block context\n            // — variable delimiter: `$foo: bar`, could be anywhere\n            // — pseudo-selector: `a:hover`, could be anywhere (for LESS and SCSS)\n            // — media query expression: `min-width: 100px`, must be inside expression context\n            // Since I can’t easily detect `:` meaning for sure, we’ll update state\n            // to accumulate possible property name-value pair or selector\n            if (state.propertyStart === -1) {\n                state.propertyStart = state.start;\n            }\n            state.propertyEnd = state.end;\n            state.propertyDelimiter = scanner.pos - 1;\n            state.start = state.end = -1;\n        }\n        else {\n            if (state.start === -1) {\n                state.start = scanner.pos;\n            }\n            if (scanner.eat(40 /* LeftRound */)) {\n                state.expression++;\n            }\n            else if (scanner.eat(41 /* RightRound */)) {\n                state.expression--;\n            }\n            else if (!literal$3(scanner)) {\n                scanner.pos++;\n            }\n            state.end = scanner.pos;\n        }\n    }\n    if (state.propertyStart !== -1) {\n        // Pending property name\n        if (notify(\"propertyName\" /* PropertyName */, state.propertyDelimiter, state.propertyStart, state.propertyEnd)) {\n            return;\n        }\n    }\n    if (state.start !== -1) {\n        // There’s pending token in state\n        notify(state.propertyStart !== -1 ? \"propertyValue\" /* PropertyValue */ : \"propertyName\" /* PropertyName */, -1);\n    }\n}\nfunction whitespace(scanner) {\n    return scanner.eatWhile(isSpace);\n}\n/**\n * Consumes CSS comments from scanner: `/*  * /`\n * It’s possible that comment may not have closing part\n */\nfunction comment$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(47 /* Slash */) && scanner.eat(42 /* Asterisk */)) {\n        scanner.start = start;\n        while (!scanner.eof()) {\n            if (scanner.eat(42 /* Asterisk */)) {\n                if (scanner.eat(47 /* Slash */)) {\n                    return true;\n                }\n                continue;\n            }\n            scanner.pos++;\n        }\n        return true;\n    }\n    else {\n        scanner.pos = start;\n    }\n    return false;\n}\n/**\n * Consumes single- or double-quoted string literal\n */\nfunction literal$3(scanner) {\n    const ch = scanner.peek();\n    if (isQuote(ch)) {\n        scanner.start = scanner.pos++;\n        while (!scanner.eof()) {\n            if (scanner.eat(ch) || scanner.eat(10 /* LF */) || scanner.eat(13 /* CR */)) {\n                break;\n            }\n            // Skip escape character, if any\n            scanner.eat(92 /* Backslash */);\n            scanner.pos++;\n        }\n        // Do not throw if string is incomplete\n        return true;\n    }\n}\nfunction reset(state) {\n    state.start = state.end = state.propertyStart = state.propertyEnd = state.propertyDelimiter = -1;\n}\n/**\n * Check if current state is a known selector context for `:` delimiter\n */\nfunction isKnownSelectorColon(scanner, state) {\n    // Either inside expression like `(min-width: 10px)` or pseudo-element `::before`\n    return state.expression || scanner.eatWhile(58 /* Colon */);\n}\n\n// NB: no `Minus` operator, it must be handled differently\nconst operators$1 = [\n    43 /* Plus */, 47 /* Division */, 42 /* Multiplication */,\n    44 /* Comma */\n];\n/**\n * Splits given CSS value into token list\n */\nfunction splitValue(value, offset = 0) {\n    let start = -1;\n    let expression = 0;\n    let pos = 0;\n    const result = [];\n    const scanner = new Scanner(value);\n    while (!scanner.eof()) {\n        pos = scanner.pos;\n        if (scanner.eat(isSpace) || scanner.eat(isOperator$2) || isMinusOperator(scanner)) {\n            // Use space as value delimiter but only if not in expression context,\n            // e.g. `1 2` are distinct values but `(1 2)` not\n            if (!expression && start !== -1) {\n                result.push([offset + start, offset + pos]);\n                start = -1;\n            }\n            scanner.eatWhile(isSpace);\n        }\n        else {\n            if (start === -1) {\n                start = scanner.pos;\n            }\n            if (scanner.eat(40 /* LeftRound */)) {\n                expression++;\n            }\n            else if (scanner.eat(41 /* RightRound */)) {\n                expression--;\n            }\n            else if (!literal$3(scanner)) {\n                scanner.pos++;\n            }\n        }\n    }\n    if (start !== -1 && start !== scanner.pos) {\n        result.push([offset + start, offset + scanner.pos]);\n    }\n    return result;\n}\nfunction isOperator$2(ch) {\n    return operators$1.includes(ch);\n}\n/**\n * Check if current scanner state is at minus operator\n */\nfunction isMinusOperator(scanner) {\n    // Minus operator is tricky since CSS supports dashes in keyword names like\n    // `no-repeat`\n    const start = scanner.pos;\n    if (scanner.eat(45 /* Minus */) && scanner.eat(isSpace)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n\nfunction match$1(source, pos) {\n    const pool = [];\n    const stack = [];\n    let result = null;\n    let pendingProperty = null;\n    const releasePending = () => {\n        if (pendingProperty) {\n            releaseRange(pool, pendingProperty);\n            pendingProperty = null;\n        }\n    };\n    scan$1(source, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            releasePending();\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            releasePending();\n            const parent = stack.pop();\n            if (parent && parent[0] < pos && pos < end) {\n                result = {\n                    type: 'selector',\n                    start: parent[0],\n                    end,\n                    bodyStart: parent[2] + 1,\n                    bodyEnd: start\n                };\n                return false;\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            releasePending();\n            pendingProperty = allocRange(pool, start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (pendingProperty && pendingProperty[0] < pos && pos < end) {\n                result = {\n                    type: 'property',\n                    start: pendingProperty[0],\n                    end: delimiter + 1,\n                    bodyStart: start,\n                    bodyEnd: end\n                };\n                return false;\n            }\n            releasePending();\n        }\n    });\n    return result;\n}\n/**\n * Returns balanced CSS model: a list of all ranges that could possibly match\n * given location when moving in outward direction\n */\nfunction balancedOutward$1(source, pos) {\n    const pool = [];\n    const stack = [];\n    const result = [];\n    let property = null;\n    scan$1(source, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            const left = stack.pop();\n            if (left && left[0] < pos && end > pos) {\n                // Matching section found\n                const inner = innerRange(source, left[2] + 1, start);\n                inner && push(result, inner);\n                push(result, [left[0], end]);\n            }\n            left && releaseRange(pool, left);\n            if (!stack.length) {\n                return false;\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            property && releaseRange(pool, property);\n            property = allocRange(pool, start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (property && property[0] < pos && Math.max(delimiter, end) > pos) {\n                // Push full token and value range\n                push(result, [start, end]);\n                push(result, [property[0], delimiter !== -1 ? delimiter + 1 : end]);\n            }\n        }\n        if (type !== \"propertyName\" /* PropertyName */ && property) {\n            releaseRange(pool, property);\n            property = null;\n        }\n    });\n    return result;\n}\n/**\n * Returns balanced CSS selectors: a list of all ranges that could possibly match\n * given location when moving in inward direction\n */\nfunction balancedInward$1(source, pos) {\n    // Collecting ranges for inward balancing is a bit trickier: we have to store\n    // first child of every matched selector until we find the one that matches given\n    // location\n    const pool = [];\n    const stack = [];\n    const result = [];\n    let pendingProperty = null;\n    const alloc = (start, end, delimiter) => {\n        if (pool.length) {\n            const range = pool.pop();\n            range.start = start;\n            range.end = end;\n            range.delimiter = delimiter;\n            return range;\n        }\n        return { start, end, delimiter, firstChild: null };\n    };\n    const release = (range) => {\n        range.firstChild = null;\n        pool.push(range);\n    };\n    const releasePending = () => {\n        if (pendingProperty) {\n            release(pendingProperty);\n            pendingProperty = null;\n        }\n    };\n    /**\n     * Pushes given inward range as a first child of current selector only if it’s\n     * not set yet\n     */\n    const pushChild = (start, end, delimiter) => {\n        const parent = last$3(stack);\n        if (parent && !parent.firstChild) {\n            parent.firstChild = alloc(start, end, delimiter);\n        }\n    };\n    scan$1(source, (type, start, end, delimiter) => {\n        if (type === \"blockEnd\" /* BlockEnd */) {\n            releasePending();\n            let range = stack.pop();\n            if (!range) {\n                // Some sort of lone closing brace, ignore it\n                return;\n            }\n            if (range.start <= pos && pos <= end) {\n                // Matching selector found: add it and its inner range into result\n                let inner = innerRange(source, range.delimiter + 1, start);\n                push(result, [range.start, end]);\n                inner && push(result, inner);\n                while (range.firstChild) {\n                    const child = range.firstChild;\n                    inner = innerRange(source, child.delimiter + 1, child.end - 1);\n                    push(result, [child.start, child.end]);\n                    inner && push(result, inner);\n                    range = child;\n                }\n                return false;\n            }\n            else {\n                const parent = last$3(stack);\n                if (parent && !parent.firstChild) {\n                    // No first child in parent node: store current selector\n                    range.end = end;\n                    parent.firstChild = range;\n                }\n                else {\n                    release(range);\n                }\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            releasePending();\n            pendingProperty = alloc(start, end, delimiter);\n            pushChild(start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (pendingProperty) {\n                if (pendingProperty.start <= pos && end >= pos) {\n                    // Direct hit into property, no need to look further\n                    push(result, [pendingProperty.start, delimiter + 1]);\n                    push(result, [start, end]);\n                    releasePending();\n                    return false;\n                }\n                const parent = last$3(stack);\n                if (parent && parent.firstChild && parent.firstChild.start === pendingProperty.start) {\n                    // First child is an expected property name, update its range\n                    // to include property value\n                    parent.firstChild.end = delimiter !== -1 ? delimiter + 1 : end;\n                }\n                releasePending();\n            }\n        }\n        else {\n            // Selector start\n            stack.push(alloc(start, end, delimiter));\n            releasePending();\n        }\n    });\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns inner range for given selector bounds: narrows it to first non-empty\n * region. If resulting region is empty, returns `null`\n */\nfunction innerRange(source, start, end) {\n    while (start < end && isSpace(source.charCodeAt(start))) {\n        start++;\n    }\n    while (end > start && isSpace(source.charCodeAt(end - 1))) {\n        end--;\n    }\n    return start !== end ? [start, end] : null;\n}\nfunction allocRange(pool, start, end, delimiter) {\n    if (pool.length) {\n        const range = pool.pop();\n        range[0] = start;\n        range[1] = end;\n        range[2] = delimiter;\n        return range;\n    }\n    return [start, end, delimiter];\n}\nfunction releaseRange(pool, range) {\n    range && pool.push(range);\n    return null;\n}\nfunction push(ranges, range) {\n    const prev = ranges.length ? ranges[ranges.length - 1] : null;\n    if ((!prev || prev[0] !== range[0] || prev[1] !== range[1]) && range[0] !== range[1]) {\n        ranges.push(range);\n    }\n}\nfunction last$3(arr) {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parseAbbreviation(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push$1(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push$1(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push$1(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push$1(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue$1(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue$1(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField$1(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder$2(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder$2(scanner) {\n    if (peek$2(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek$2(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek$2(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek$2(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField$1);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField$1) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push$1(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push$1(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push$1(out, ' '.repeat(maxLength - lineLengths[i]));\n                push$1(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        abbr = parseAbbreviation(abbr, parseOpt);\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify$1(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt$1 = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse(value.trim(), opt$1)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push$1(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push$1(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push$1(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push$1(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push$1(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push$1(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push$1(out, ' ');\n        }\n        push$1(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push$1(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push$1(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push$1(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push$1(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push$1(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field$2(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal$4(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field$2(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal$4(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal$4(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal$4(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field$2(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field$2(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field$2(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field$2(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field$2(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field$2(state.index++, v.name), literal$4('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal$4(', '));\n                    }\n                }\n                value.push(literal$4(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${1});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:grid|inline-grid|subgrid|block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat()|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat()|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions$1 = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig$1 = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions$1\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig$1), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig$1[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek$1$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume$2(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1$1(scanner))\n        : match === peek$1$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume$2(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote$2(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote$2(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume$2(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume$2(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace$3);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume$2(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume$2(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume$2(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume$2(scanner, isWhiteSpace$3)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume$2(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume$2(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1$1(scanner);\n        if (isCloseBracket$1(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket$2(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume$2(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha$1(ch) || isNumber$1(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha$1(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber$1(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace$3(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace$3(ch) && !isQuote$2(ch);\n}\nfunction isOpenBracket$2(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket$1(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote$2(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray$1(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume$2(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume$2(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray$1(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume$2(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify$1(parse$1(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1$1(abbr, config), config);\n}\n\nconst pairs = {\n    '{': '}',\n    '[': ']',\n    '(': ')'\n};\nconst pairsEnd = [];\nfor (const key of Object.keys(pairs)) {\n    pairsEnd.push(pairs[key]);\n}\n/**\n * Returns `true` if given character code is a space\n */\nfunction isSpace$1(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160 /* non-breaking space */\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\nfunction pushRange(ranges, range) {\n    const prev = ranges[ranges.length - 1];\n    if (range && range[0] !== range[1] && (!prev || prev[0] !== range[0] || prev[1] !== range[1])) {\n        ranges.push(range);\n    }\n}\n/**\n * Returns ranges of tokens in given value. Tokens are space-separated words.\n */\nfunction tokenList(value, offset = 0) {\n    const ranges = [];\n    const len = value.length;\n    let pos = 0;\n    let start = 0;\n    let end = 0;\n    while (pos < len) {\n        end = pos;\n        const ch = value.charCodeAt(pos++);\n        if (isSpace$1(ch)) {\n            if (start !== end) {\n                ranges.push([offset + start, offset + end]);\n            }\n            while (isSpace$1(value.charCodeAt(pos))) {\n                pos++;\n            }\n            start = pos;\n        }\n    }\n    if (start !== pos) {\n        ranges.push([offset + start, offset + pos]);\n    }\n    return ranges;\n}\n/**\n * Check if given character is a quote\n */\nfunction isQuote$3(ch) {\n    return ch === '\"' || ch === '\\'';\n}\n/**\n * Returns value of given attribute, parsed by Emmet HTML matcher\n */\nfunction attributeValue$1(attr) {\n    const { value } = attr;\n    return value && isQuoted(value)\n        ? value.slice(1, -1)\n        : value;\n}\nfunction attributeValueRange(tag, attr, offset = 0) {\n    let valueStart = attr.valueStart;\n    let valueEnd = attr.valueEnd;\n    if (isQuote$3(tag[valueStart])) {\n        valueStart++;\n    }\n    if (isQuote$3(tag[valueEnd - 1]) && valueEnd > valueStart) {\n        valueEnd--;\n    }\n    return [offset + valueStart, offset + valueEnd];\n}\n/**\n * Check if given value is either quoted or written as expression\n */\nfunction isQuoted(value) {\n    return !!value && (isQuotedString(value) || isExprString(value));\n}\n/**\n * Check if given string is quoted with single or double quotes\n */\nfunction isQuotedString(str) {\n    return str.length > 1 && isQuote$3(str[0]) && str[0] === str.slice(-1);\n}\n/**\n * Check if given string contains expression, e.g. wrapped with `{` and `}`\n */\nfunction isExprString(str) {\n    return str[0] === '{' && str.slice(-1) === '}';\n}\n/**\n * Returns last element of given array\n */\nfunction last$4(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n/**\n * Returns list of matched tags in given source code\n */\nfunction getTagMatches(code, options) {\n    const opt = createOptions(options);\n    const stack = [];\n    const result = [];\n    scan(code, (name, type, start, end) => {\n        if (type === 3 /* SelfClose */) {\n            result.push({ name, open: [start, end] });\n        }\n        else if (type === 1 /* Open */) {\n            const item = { name, open: [start, end] };\n            stack.push(item);\n            result.push(item);\n        }\n        else {\n            // Handle closing tag\n            while (stack.length) {\n                const item = stack.pop();\n                if (item.name === name) {\n                    item.close = [start, end];\n                    break;\n                }\n            }\n        }\n    }, opt);\n    return result;\n}\n/**\n * Finds tag match for given position\n */\nfunction findTagMatch(source, pos, options) {\n    if (typeof source === 'string') {\n        source = getTagMatches(source, options);\n    }\n    let candidate;\n    source.some(match => {\n        const start = match.open[0];\n        const end = match.close ? match.close[1] : match.open[1];\n        if (pos < start) {\n            // All the following tags will be after given position, stop searching\n            return true;\n        }\n        if (pos > start && pos < end) {\n            candidate = match;\n        }\n    });\n    return candidate;\n}\n/**\n * Returns list of ranges for Select Next/Previous Item action\n */\nfunction selectItemHTML(code, pos, isPrev) {\n    return isPrev ? selectPreviousItem(code, pos) : selectNextItem(code, pos);\n}\n/**\n * Returns list of ranges for Select Next Item action\n */\nfunction selectNextItem(code, pos) {\n    let result = void 0;\n    // Find open or self-closing tag, closest to given position\n    scan(code, (name, type, start, end) => {\n        if ((type === 1 /* Open */ || type === 3 /* SelfClose */) && end > pos) {\n            // Found open or self-closing tag\n            result = getTagSelectionModel(code, name, start, end);\n            return false;\n        }\n    });\n    return result;\n}\n/**\n * Returns list of ranges for Select Previous Item action\n */\nfunction selectPreviousItem(code, pos) {\n    let lastType = null;\n    let lastName = '';\n    let lastStart = -1;\n    let lastEnd = -1;\n    // We should find the closest open or self-closing tag left to given `pos`.\n    scan(code, (name, type, start, end) => {\n        if (start >= pos) {\n            return false;\n        }\n        if (type === 1 /* Open */ || type === 3 /* SelfClose */) {\n            // Found open or self-closing tag\n            lastName = name;\n            lastType = type;\n            lastStart = start;\n            lastEnd = end;\n        }\n    });\n    if (lastType !== null) {\n        return getTagSelectionModel(code, lastName, lastStart, lastEnd);\n    }\n}\n/**\n * Parses open or self-closing tag in `start:end` range of `code` and returns its\n * model for selecting items\n * @param code Document source code\n * @param name Name of matched tag\n */\nfunction getTagSelectionModel(code, name, start, end) {\n    const ranges = [\n        // Add tag name range\n        [start + 1, start + 1 + name.length]\n    ];\n    // Parse and add attributes ranges\n    const tagSrc = code.slice(start, end);\n    for (const attr of attributes(tagSrc, name)) {\n        if (attr.value != null) {\n            // Attribute with value\n            pushRange(ranges, [start + attr.nameStart, start + attr.valueEnd]);\n            // Add (unquoted) value range\n            const val = valueRange(attr);\n            if (val[0] !== val[1]) {\n                pushRange(ranges, [start + val[0], start + val[1]]);\n                if (attr.name === 'class') {\n                    // For class names, split value into space-separated tokens\n                    const tokens = tokenList(tagSrc.slice(val[0], val[1]), start + val[0]);\n                    for (const token of tokens) {\n                        pushRange(ranges, token);\n                    }\n                }\n            }\n        }\n        else {\n            // Attribute without value (boolean)\n            pushRange(ranges, [start + attr.nameStart, start + attr.nameEnd]);\n        }\n    }\n    return { start, end, ranges };\n}\n/**\n * Returns value range of given attribute. Value range is unquoted.\n */\nfunction valueRange(attr) {\n    const value = attr.value;\n    const ch = value[0];\n    const lastCh = value[value.length - 1];\n    if (ch === '\"' || ch === '\\'') {\n        return [\n            attr.valueStart + 1,\n            attr.valueEnd - (lastCh === ch ? 1 : 0)\n        ];\n    }\n    if (ch === '{' && lastCh === '}') {\n        return [\n            attr.valueStart + 1,\n            attr.valueEnd - 1\n        ];\n    }\n    return [attr.valueStart, attr.valueEnd];\n}\n/**\n * Returns list of ranges for Select Next/Previous CSS Item  action\n */\nfunction selectItemCSS(code, pos, isPrev) {\n    return isPrev ? selectPreviousItem$1(code, pos) : selectNextItem$1(code, pos);\n}\n/**\n * Returns regions for selecting next item in CSS\n */\nfunction selectNextItem$1(code, pos) {\n    let result = void 0;\n    let pendingProperty = void 0;\n    scan$1(code, (type, start, end, delimiter) => {\n        if (start < pos) {\n            return;\n        }\n        if (type === \"selector\" /* Selector */) {\n            result = { start, end, ranges: [[start, end]] };\n            return false;\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            pendingProperty = [start, end, delimiter];\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            result = {\n                start,\n                end: delimiter !== -1 ? delimiter + 1 : end,\n                ranges: []\n            };\n            if (pendingProperty) {\n                // Full property range\n                result.start = pendingProperty[0];\n                pushRange(result.ranges, [pendingProperty[0], result.end]);\n            }\n            // Full value range\n            pushRange(result.ranges, [start, end]);\n            // Value fragments\n            for (const r of splitValue(code.substring(start, end))) {\n                pushRange(result.ranges, [r[0] + start, r[1] + start]);\n            }\n            return false;\n        }\n        else if (pendingProperty) {\n            result = {\n                start: pendingProperty[0],\n                end: pendingProperty[1],\n                ranges: [[pendingProperty[0], pendingProperty[1]]]\n            };\n            return false;\n        }\n    });\n    return result;\n}\n/**\n * Returns regions for selecting previous item in CSS\n */\nfunction selectPreviousItem$1(code, pos) {\n    const state = {\n        type: null,\n        start: -1,\n        end: -1,\n        valueStart: -1,\n        valueEnd: -1,\n        valueDelimiter: -1,\n    };\n    scan$1(code, (type, start, end, delimiter) => {\n        // Accumulate context until we reach given position\n        if (start >= pos && type !== \"propertyValue\" /* PropertyValue */) {\n            return false;\n        }\n        if (type === \"selector\" /* Selector */ || type === \"propertyName\" /* PropertyName */) {\n            state.start = start;\n            state.end = end;\n            state.type = type;\n            state.valueStart = state.valueEnd = state.valueDelimiter = -1;\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            state.valueStart = start;\n            state.valueEnd = end;\n            state.valueDelimiter = delimiter;\n        }\n    });\n    if (state.type === \"selector\" /* Selector */) {\n        return {\n            start: state.start,\n            end: state.end,\n            ranges: [[state.start, state.end]]\n        };\n    }\n    if (state.type === \"propertyName\" /* PropertyName */) {\n        const result = {\n            start: state.start,\n            end: state.end,\n            ranges: []\n        };\n        if (state.valueStart !== -1) {\n            result.end = state.valueDelimiter !== -1 ? state.valueDelimiter + 1 : state.valueEnd;\n            // Full property range\n            pushRange(result.ranges, [state.start, result.end]);\n            // Full value range\n            pushRange(result.ranges, [state.valueStart, state.valueEnd]);\n            // Value fragments\n            for (const r of splitValue(code.substring(state.valueStart, state.valueEnd))) {\n                pushRange(result.ranges, [r[0] + state.valueStart, r[1] + state.valueStart]);\n            }\n        }\n        else {\n            pushRange(result.ranges, [state.start, state.end]);\n        }\n        return result;\n    }\n}\n\n/**\n * Returns HTML context for given location in source code\n */\nfunction getHTMLContext(code, pos, opt = {}) {\n    const result = {\n        type: 'html',\n        ancestors: [],\n        current: null,\n        css: null\n    };\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool = [];\n    const stack = [];\n    const options = createOptions({ xml: opt.xml, allTokens: true });\n    scan(code, (name, type, start, end) => {\n        if (start >= pos) {\n            // Moved beyond location, stop parsing\n            return false;\n        }\n        if (start < pos && pos < end) {\n            // Direct hit on element\n            result.current = { name, type, range: [start, end] };\n            return false;\n        }\n        if (type === 1 /* Open */ && isSelfClose$1(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = 3 /* SelfClose */;\n        }\n        if (type === 1 /* Open */) {\n            // Allocate tag object from pool\n            stack.push(allocItem(pool, name, type, start, end));\n        }\n        else if (type === 2 /* Close */ && stack.length && last$4(stack).name === name) {\n            // Release tag object for further re-use\n            releaseItem(pool, stack.pop());\n        }\n    }, options);\n    // Record stack elements as ancestors\n    stack.forEach(item => {\n        result.ancestors.push({\n            name: item.name,\n            range: [item.start, item.end]\n        });\n    });\n    if (!opt.skipCSS) {\n        // Detect if position is inside CSS context\n        result.css = detectCSSContextFromHTML(code, pos, result);\n    }\n    return result;\n}\n/**\n * Returns CSS context for given location in source code\n */\nfunction getCSSContext(code, pos, embedded) {\n    const result = {\n        type: 'css',\n        ancestors: [],\n        current: null,\n        inline: false,\n        embedded\n    };\n    const pool = [];\n    const stack = [];\n    scan$1(code, (type, start, end) => {\n        if (start >= pos) {\n            // Token behind specified location, stop parsing\n            return false;\n        }\n        if (start < pos && pos <= end) {\n            // Direct hit on token\n            result.current = {\n                name: code.slice(start, end),\n                type,\n                range: [start, end]\n            };\n            return false;\n        }\n        switch (type) {\n            case \"selector\" /* Selector */:\n            case \"propertyName\" /* PropertyName */:\n                stack.push(allocItem(pool, code.slice(start, end), type, start, end));\n                break;\n            case \"propertyValue\" /* PropertyValue */:\n            case \"blockEnd\" /* BlockEnd */:\n                stack.pop();\n                break;\n        }\n    });\n    stack.forEach(item => {\n        result.ancestors.push({\n            name: item.name,\n            type: item.type,\n            range: [item.start, item.end]\n        });\n    });\n    return result;\n}\n/**\n * Returns embedded stylesheet syntax from given HTML context\n */\nfunction getEmbeddedStyleSyntax(code, ctx) {\n    const parent = last$4(ctx.ancestors);\n    if (parent && parent.name === 'style') {\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            if (attr.name === 'type') {\n                return attributeValue$1(attr);\n            }\n        }\n    }\n}\n/**\n * Returns context for Emmet abbreviation from given HTML context\n */\nfunction getMarkupAbbreviationContext(code, ctx) {\n    const parent = last$4(ctx.ancestors);\n    if (parent) {\n        const attrs = {};\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            attrs[attr.name] = attributeValue$1(attr) || '';\n        }\n        return {\n            name: parent.name,\n            attributes: attrs\n        };\n    }\n}\n/**\n * Returns context for Emmet abbreviation from given CSS context\n */\nfunction getStylesheetAbbreviationContext(ctx) {\n    if (ctx.inline) {\n        return { name: \"@@property\" /* Property */ };\n    }\n    const parent = last$4(ctx.ancestors);\n    let scope = \"@@global\" /* Global */;\n    if (ctx.current) {\n        if (ctx.current.type === \"propertyValue\" /* PropertyValue */ && parent) {\n            scope = parent.name;\n        }\n        else if ((ctx.current.type === \"selector\" /* Selector */ || ctx.current.type === \"propertyName\" /* PropertyName */) && !parent) {\n            scope = \"@@section\" /* Section */;\n        }\n    }\n    return {\n        name: scope\n    };\n}\n/**\n * Tries to detect CSS context from given HTML context and returns it\n */\nfunction detectCSSContextFromHTML(code, pos, ctx) {\n    let cssCtx = null;\n    if (ctx.current) {\n        // Maybe inline CSS?\n        const elem = ctx.current;\n        if (elem.type === 1 /* Open */ || elem.type === 2 /* Close */) {\n            const tag = code.slice(elem.range[0], elem.range[1]);\n            attributes(tag, elem.name).some(attr => {\n                if (attr.name === 'style' && attr.value != null) {\n                    const [valueStart, valueEnd] = attributeValueRange(tag, attr, elem.range[0]);\n                    if (pos >= valueStart && pos <= valueEnd) {\n                        cssCtx = getCSSContext(code.slice(valueStart, valueEnd), pos - valueStart, [valueStart, valueEnd]);\n                        applyOffset(cssCtx, valueStart);\n                        cssCtx.inline = true;\n                        return true;\n                    }\n                }\n            });\n        }\n    }\n    else if (ctx.ancestors.length) {\n        // Maybe inside `<style>` element?\n        const parent = last$4(ctx.ancestors);\n        if (parent.name === 'style') {\n            // Find closing </style> tag\n            const styleStart = parent.range[1];\n            let styleEnd = code.length;\n            scan(code.slice(parent.range[1]), (name, type, start) => {\n                if (name === parent.name && type === 2 /* Close */) {\n                    styleEnd = start + styleStart;\n                    return false;\n                }\n            });\n            cssCtx = getCSSContext(code.slice(styleStart, styleEnd), pos - styleStart, [styleStart, styleEnd]);\n            applyOffset(cssCtx, styleStart);\n        }\n    }\n    return cssCtx;\n}\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose$1(name, options) {\n    return !options.xml && options.empty.includes(name);\n}\nfunction allocItem(pool, name, type, start, end) {\n    if (pool.length) {\n        const tag = pool.pop();\n        tag.name = name;\n        tag.type = type;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, type, start, end };\n}\nfunction releaseItem(pool, item) {\n    pool.push(item);\n}\nfunction applyOffset(ctx, offset) {\n    ctx.ancestors.forEach(item => {\n        offsetRange(item.range, offset);\n    });\n    if (ctx.current) {\n        offsetRange(ctx.current.range, offset);\n    }\n}\nfunction offsetRange(range, offset) {\n    range[0] += offset;\n    range[1] += offset;\n}\n\nconst JSX_PREFIX = '<';\nconst reJSXAbbrStart = /^[a-zA-Z.#\\[\\(]$/;\nconst reWordBound = /^[\\s>;\"\\']?[a-zA-Z.#!@\\[\\(]$/;\nconst reStylesheetWordBound = /^[\\s;\"\\']?[a-zA-Z!@]$/;\n/**\n * Controller for tracking Emmet abbreviations in editor as user types.\n * Controller designed to be extended ad-hoc in editor plugins, overriding some\n * methods `mark()` to match editor behavior\n */\nclass AbbreviationTrackingController {\n    constructor() {\n        this.cache = new Map();\n        this.trackers = new Map();\n        this.lastPos = new Map();\n    }\n    /**\n     * Returns last known location of caret in given editor\n     */\n    getLastPost(editor) {\n        return this.lastPos.get(editor.id);\n    }\n    /**\n     * Sets last known caret location for given editor\n     */\n    setLastPos(editor, pos) {\n        this.lastPos.set(editor.id, pos);\n    }\n    /**\n     * Returns abbreviation tracker for given editor, if any\n     */\n    getTracker(editor) {\n        return this.trackers.get(editor.id);\n    }\n    /**\n     * Detects if user is typing abbreviation at given location\n     */\n    typingAbbreviation(editor, pos) {\n        var _a;\n        // Start tracking only if user starts abbreviation typing: entered first\n        // character at the word bound\n        // NB: get last 2 characters: first should be a word bound(or empty),\n        // second must be abbreviation start\n        const prefix = editor.substr(Math.max(0, pos - 2), pos);\n        const syntax = editor.syntax();\n        let start = -1;\n        let end = pos;\n        let offset = 0;\n        if (editor.isJSX(syntax)) {\n            // In JSX, abbreviations should be prefixed\n            if (prefix.length === 2 && prefix[0] === JSX_PREFIX && reJSXAbbrStart.test(prefix[1])) {\n                start = pos - 2;\n                offset = JSX_PREFIX.length;\n            }\n        }\n        else if (reWordBound.test(prefix)) {\n            start = pos - 1;\n        }\n        if (start >= 0) {\n            // Check if there’s paired character\n            const lastCh = prefix[prefix.length - 1];\n            if (lastCh in pairs && editor.substr(pos, pos + 1) === pairs[lastCh]) {\n                end++;\n            }\n            const config = this.getActivationContext(editor, pos);\n            if (config) {\n                if (config.type === 'stylesheet' && !reStylesheetWordBound.test(prefix)) {\n                    // Additional check for stylesheet abbreviation start: it’s slightly\n                    // differs from markup prefix, but we need activation context\n                    // to ensure that context under caret is CSS\n                    return;\n                }\n                const tracker = this.startTracking(editor, start, end, { offset, config });\n                if (tracker && tracker.type === \"abbreviation\" /* Abbreviation */ && ((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n                    // Make a silly check for section context: if user start typing\n                    // CSS selector at the end of file, it will be treated as property\n                    // name and provide unrelated completion by default.\n                    // We should check if captured abbreviation actually matched\n                    // snippet to continue. Otherwise, ignore this abbreviation.\n                    // By default, unresolved abbreviations are converted to CSS properties,\n                    // e.g. `a` → `a: ;`. If that’s the case, stop tracking\n                    const { abbreviation, preview } = tracker;\n                    if (preview.startsWith(abbreviation) && /^:\\s*;?$/.test(preview.slice(abbreviation.length))) {\n                        this.stopTracking(editor);\n                        return;\n                    }\n                }\n                return tracker;\n            }\n        }\n    }\n    /**\n     * Starts abbreviation tracking for given editor\n     * @param start Location of abbreviation start\n     * @param pos Current caret position, must be greater that `start`\n     */\n    startTracking(editor, start, pos, params) {\n        const config = (params === null || params === void 0 ? void 0 : params.config) || editor.config(start);\n        const tracker = this.createTracker(editor, [start, pos], Object.assign({ config }, params));\n        if (tracker) {\n            this.trackers.set(editor.id, tracker);\n            return tracker;\n        }\n        this.trackers.delete(editor.id);\n    }\n    /**\n     * Stops abbreviation tracking in given editor instance\n     */\n    stopTracking(editor, params) {\n        const tracker = this.getTracker(editor);\n        if (tracker) {\n            editor.unmark(tracker);\n            if (tracker.forced && !(params === null || params === void 0 ? void 0 : params.skipRemove)) {\n                // Contents of forced abbreviation must be removed\n                editor.replace('', tracker.range[0], tracker.range[1]);\n            }\n            if (params === null || params === void 0 ? void 0 : params.force) {\n                this.cache.delete(editor.id);\n            }\n            else {\n                // Store tracker in history to restore it if user continues editing\n                this.storeTracker(editor, tracker);\n            }\n            this.trackers.delete(editor.id);\n        }\n    }\n    /**\n     * Creates abbreviation tracker for given range in editor. Parses contents\n     * of abbreviation in range and returns either valid abbreviation tracker,\n     * error tracker or `null` if abbreviation cannot be created from given range\n     */\n    createTracker(editor, range, params) {\n        if (range[0] >= range[1]) {\n            // Invalid range\n            return null;\n        }\n        let abbreviation = editor.substr(range[0], range[1]);\n        const { config } = params;\n        if (params.offset) {\n            abbreviation = abbreviation.slice(params.offset);\n        }\n        // Basic validation: do not allow empty abbreviations\n        // or newlines in abbreviations\n        if (!abbreviation || /[\\r\\n]/.test(abbreviation)) {\n            return null;\n        }\n        const base = {\n            abbreviation,\n            range,\n            config,\n            forced: !!params.forced,\n            offset: params.offset || 0,\n            lastPos: range[1],\n            lastLength: editor.size(),\n        };\n        try {\n            let parsedAbbr;\n            let simple = false;\n            if (config.type === 'stylesheet') {\n                parsedAbbr = parse(abbreviation);\n            }\n            else {\n                parsedAbbr = parseAbbreviation(abbreviation, {\n                    jsx: config.syntax === 'jsx'\n                });\n                simple = this.isSimpleMarkupAbbreviation(parsedAbbr);\n            }\n            const previewConfig = editor.previewConfig(config);\n            return Object.assign(Object.assign({}, base), { type: \"abbreviation\" /* Abbreviation */, simple, preview: expandAbbreviation(parsedAbbr, previewConfig) });\n        }\n        catch (error) {\n            return Object.assign(Object.assign({}, base), { type: \"error\" /* Error */, error });\n        }\n    }\n    /**\n     * Stores given tracker in separate cache to restore later\n     */\n    storeTracker(editor, tracker) {\n        this.cache.set(editor.id, tracker);\n    }\n    /**\n     * Returns stored tracker for given editor proxy, if any\n     */\n    getStoredTracker(editor) {\n        return this.cache.get(editor.id);\n    }\n    /**\n     * Tries to restore abbreviation tracker for given editor at specified position\n     */\n    restoreTracker(editor, pos) {\n        const tracker = this.getStoredTracker(editor);\n        if (tracker && tracker.range[0] <= pos && tracker.range[1] >= pos) {\n            // Tracker can be restored at given location. Make sure it’s contents matches\n            // contents of editor at the same location. If it doesn’t, reset stored tracker\n            // since it’s not valid anymore\n            this.cache.delete(editor.id);\n            const [from, to] = tracker.range;\n            if (editor.substr(from + tracker.offset, to) === tracker.abbreviation) {\n                this.trackers.set(editor.id, tracker);\n                return tracker;\n            }\n        }\n    }\n    /**\n     * Handle content change in given editor instance\n     */\n    handleChange(editor, pos) {\n        const tracker = this.getTracker(editor);\n        const editorLastPos = this.getLastPost(editor);\n        this.setLastPos(editor, pos);\n        if (!tracker) {\n            // No active tracker, check if we user is actually typing it\n            if (editorLastPos != null && editorLastPos === pos - 1 && editor.allowTracking(pos)) {\n                return this.typingAbbreviation(editor, pos);\n            }\n            return;\n        }\n        const { lastPos } = tracker;\n        let { range } = tracker;\n        if (lastPos < range[0] || lastPos > range[1]) {\n            // Updated content outside abbreviation: reset tracker\n            this.stopTracking(editor);\n            return;\n        }\n        const length = editor.size();\n        const delta = length - tracker.lastLength;\n        range = range.slice();\n        // Modify range and validate it: if it leads to invalid abbreviation, reset tracker\n        updateRange(range, delta, lastPos);\n        // Handle edge case: empty forced abbreviation is allowed\n        if (range[0] === range[1] && tracker.forced) {\n            tracker.abbreviation = '';\n            return tracker;\n        }\n        const nextTracker = this.createTracker(editor, range, tracker);\n        if (!nextTracker || (!tracker.forced && !isValidTracker(nextTracker, range, pos))) {\n            this.stopTracking(editor);\n            return;\n        }\n        nextTracker.lastPos = pos;\n        this.trackers.set(editor.id, nextTracker);\n        editor.mark(nextTracker);\n        return nextTracker;\n    }\n    /**\n     * Handle selection (caret) change in given editor instance\n     */\n    handleSelectionChange(editor, pos) {\n        this.setLastPos(editor, pos);\n        const tracker = this.getTracker(editor) || this.restoreTracker(editor, pos);\n        if (tracker) {\n            tracker.lastPos = pos;\n            return tracker;\n        }\n    }\n    /**\n     * Detects and returns valid abbreviation activation context for given location\n     * in editor which can be used for abbreviation expanding.\n     * For example, in given HTML code:\n     * `<div title=\"Sample\" style=\"\">Hello world</div>`\n     * it’s not allowed to expand abbreviations inside `<div ...>` or `</div>`,\n     * yet it’s allowed inside `style` attribute and between tags.\n     *\n     * This method ensures that given `pos` is inside location allowed for expanding\n     * abbreviations and returns context data about it.\n     *\n     * Default implementation works for any editor since it uses own parsers for HTML\n     * and CSS but might be slow: if your editor supports low-level access to document\n     * parse tree or tokens, authors should override this method and provide alternative\n     * based on editor native features.\n     */\n    getActivationContext(editor, pos) {\n        const syntax = editor.syntax();\n        const content = editor.substr();\n        if (editor.isCSS(syntax)) {\n            return this.getCSSActivationContext(editor, pos, syntax, getCSSContext(content, pos));\n        }\n        if (editor.isHTML(syntax)) {\n            const ctx = getHTMLContext(content, pos, { xml: editor.isXML(syntax) });\n            if (ctx.css) {\n                return this.getCSSActivationContext(editor, pos, getEmbeddedStyleSyntax(content, ctx) || 'css', ctx.css);\n            }\n            if (!ctx.current) {\n                return {\n                    syntax,\n                    type: 'markup',\n                    context: getMarkupAbbreviationContext(content, ctx),\n                    options: editor.outputOptions(pos)\n                };\n            }\n        }\n        else {\n            return {\n                syntax,\n                type: editor.syntaxType(syntax)\n            };\n        }\n    }\n    getCSSActivationContext(editor, pos, syntax, ctx) {\n        // CSS abbreviations can be activated only when a character is entered, e.g.\n        // it should be either property name or value.\n        // In come cases, a first character of selector should also be considered\n        // as activation context\n        if (!ctx.current) {\n            return void 0;\n        }\n        const allowedContext = ctx.current.type === \"propertyName\" /* PropertyName */\n            || ctx.current.type === \"propertyValue\" /* PropertyValue */\n            || this.isTypingBeforeSelector(editor, pos, ctx);\n        if (allowedContext) {\n            return {\n                syntax,\n                type: 'stylesheet',\n                context: getStylesheetAbbreviationContext(ctx),\n                options: editor.outputOptions(pos, ctx.inline)\n            };\n        }\n    }\n    /**\n     * Handle edge case: start typing abbreviation before selector. In this case,\n     * entered character becomes part of selector\n     * Activate only if it’s a nested section and it’s a first character of selector\n     */\n    isTypingBeforeSelector(editor, pos, { current }) {\n        if (current && current.type === \"selector\" /* Selector */ && current.range[0] === pos - 1) {\n            // Typing abbreviation before selector is tricky one:\n            // ensure it’s on its own line\n            const line = editor.substr(current.range[0], current.range[1]).split(/[\\n\\r]/)[0];\n            return line.trim().length === 1;\n        }\n        return false;\n    }\n    /**\n     * Check if given parsed markup abbreviation is simple.A simple abbreviation\n     * may not be displayed to user as preview to reduce distraction\n     */\n    isSimpleMarkupAbbreviation(abbr) {\n        if (abbr.children.length === 1 && !abbr.children[0].children.length) {\n            // Single element: might be a HTML element or text snippet\n            const first = abbr.children[0];\n            // XXX silly check for common snippets like `!`. Should read contents\n            // of expanded abbreviation instead\n            return !first.name || /^[a-z]/i.test(first.name);\n        }\n        return !abbr.children.length;\n    }\n    /**\n     * Method should be called when given editor instance will be no longer\n     * available to clean up cached data\n     */\n    disposeEditor(editor) {\n        this.cache.delete(editor.id);\n        this.trackers.delete(editor.id);\n        this.lastPos.delete(editor.id);\n    }\n}\nfunction updateRange(range, delta, lastPos) {\n    if (delta < 0) {\n        // Content removed\n        if (lastPos === range[0]) {\n            // Updated content at the abbreviation edge\n            range[0] += delta;\n            range[1] += delta;\n        }\n        else if (range[0] < lastPos && lastPos <= range[1]) {\n            range[1] += delta;\n        }\n    }\n    else if (delta > 0 && range[0] <= lastPos && lastPos <= range[1]) {\n        // Content inserted\n        range[1] += delta;\n    }\n    return range;\n}\n/**\n * Check if given tracker is in valid state for keeping it marked\n */\nfunction isValidTracker(tracker, range, pos) {\n    if (tracker.type === \"error\" /* Error */) {\n        if (range[1] === pos) {\n            // Last entered character is invalid\n            return false;\n        }\n        const { abbreviation } = tracker;\n        const start = range[0];\n        let targetPos = range[1];\n        while (targetPos > start) {\n            if (pairsEnd.includes(abbreviation[targetPos - start - 1])) {\n                targetPos--;\n            }\n            else {\n                break;\n            }\n        }\n        return targetPos !== pos;\n    }\n    return true;\n}\n\n/** Characters to indicate tab stop start and end in generated snippet */\nconst tabStopStart = String.fromCodePoint(0xFFF0);\nconst tabStopEnd = String.fromCodePoint(0xFFF1);\nconst stateKey = '$$emmet';\nconst pairs$1 = {\n    '{': '}',\n    '[': ']',\n    '(': ')'\n};\nfor (const key of Object.keys(pairs$1)) {\n}\nlet idCounter = 0;\n/**\n * Returns copy of region which starts and ends at non-space character\n */\nfunction narrowToNonSpace(editor, range) {\n    const text = substr(editor, range);\n    let startOffset = 0;\n    let endOffset = text.length;\n    while (startOffset < endOffset && isSpace$2(text[startOffset])) {\n        startOffset++;\n    }\n    while (endOffset > startOffset && isSpace$2(text[endOffset - 1])) {\n        endOffset--;\n    }\n    return [range[0] + startOffset, range[0] + endOffset];\n}\n/**\n * Replaces given range in editor with snippet contents\n */\nfunction replaceWithSnippet(editor, range, snippet) {\n    let fieldStartIx = snippet.indexOf(tabStopStart);\n    let fieldEndIx = snippet.indexOf(tabStopEnd);\n    let selFrom;\n    let selTo;\n    if (fieldStartIx !== -1 && fieldEndIx !== -1) {\n        selFrom = range[0] + fieldStartIx;\n        selTo = range[0] + fieldEndIx - tabStopStart.length;\n        snippet = snippet.slice(0, fieldStartIx)\n            + snippet.slice(fieldStartIx + tabStopStart.length, fieldEndIx)\n            + snippet.slice(fieldEndIx + tabStopEnd.length);\n    }\n    else if (fieldStartIx !== -1) {\n        selFrom = range[0] + fieldStartIx;\n        snippet = snippet.slice(0, fieldStartIx)\n            + snippet.slice(fieldStartIx + tabStopStart.length);\n    }\n    return editor.operation(() => {\n        const [from, to] = toRange(editor, range);\n        editor.replaceRange(snippet, from, to);\n        // Position cursor\n        if (selFrom != null) {\n            const selFromPos = editor.posFromIndex(selFrom);\n            const selToPos = selTo != null ? editor.posFromIndex(selTo) : void 0;\n            if (selToPos) {\n                editor.setSelection(selFromPos, selToPos);\n            }\n            else {\n                editor.setCursor(selFromPos);\n            }\n        }\n        return true;\n    });\n}\n/**\n * Returns current caret position for single selection\n */\nfunction getCaret(editor) {\n    const pos = editor.getCursor();\n    return editor.indexFromPos(pos);\n}\n/**\n * Returns full text content of given editor\n */\nfunction getContent(editor) {\n    return editor.getValue();\n}\n/**\n * Returns substring of given editor content for specified range\n */\nfunction substr(editor, range) {\n    const [from, to] = toRange(editor, range);\n    return editor.getRange(from, to);\n}\n/**\n * Converts given index range to editor’s position range\n */\nfunction toRange(editor, range) {\n    return [\n        editor.posFromIndex(range[0]),\n        editor.posFromIndex(range[1])\n    ];\n}\n/**\n * Returns value of given attribute, parsed by Emmet HTML matcher\n */\nfunction attributeValue$2(attr) {\n    const { value } = attr;\n    return value && isQuoted$1(value)\n        ? value.slice(1, -1)\n        : value;\n}\n/**\n * Check if given value is either quoted or written as expression\n */\nfunction isQuoted$1(value) {\n    return !!value && (isQuotedString$1(value) || isExprString$1(value));\n}\nfunction isQuote$4(ch) {\n    return ch === '\"' || ch === \"'\";\n}\n/**\n * Check if given string is quoted with single or double quotes\n */\nfunction isQuotedString$1(str) {\n    return str.length > 1 && isQuote$4(str[0]) && str[0] === str.slice(-1);\n}\n/**\n * Check if given string contains expression, e.g. wrapped with `{` and `}`\n */\nfunction isExprString$1(str) {\n    return str[0] === '{' && str.slice(-1) === '}';\n}\nfunction isSpace$2(ch) {\n    return /^[\\s\\n\\r]+$/.test(ch);\n}\nfunction htmlEscape(str) {\n    const replaceMap = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '&': '&amp;',\n    };\n    return str.replace(/[<>&]/g, ch => replaceMap[ch]);\n}\n/**\n * Returns special object for bypassing command handling\n */\nfunction pass(editor) {\n    return editor.constructor['Pass'];\n}\n/**\n * Converts given CodeMirror range to text range\n */\nfunction textRange(editor, range) {\n    const head = editor.indexFromPos(range.head);\n    const anchor = editor.indexFromPos(range.anchor);\n    return [\n        Math.min(head, anchor),\n        Math.max(head, anchor)\n    ];\n}\n/**\n * Check if `a` and `b` contains the same range\n */\nfunction rangesEqual(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Check if range `a` fully contains range `b`\n */\nfunction rangeContains(a, b) {\n    return a[0] <= b[0] && a[1] >= b[1];\n}\n/**\n * Check if given range is empty\n */\nfunction rangeEmpty(r) {\n    return r[0] === r[1];\n}\n/**\n * Generates snippet with error pointer\n */\nfunction errorSnippet(err, baseClass = 'emmet-error-snippet') {\n    const msg = err.message.split('\\n')[0];\n    const spacer = ' '.repeat(err.pos || 0);\n    return `<div class=\"${baseClass}\">\n        <div class=\"${baseClass}-ptr\">\n            <div class=\"${baseClass}-line\"></div>\n            <div class=\"${baseClass}-tip\"></div>\n            <div class=\"${baseClass}-spacer\">${spacer}</div>\n        </div>\n        <div class=\"${baseClass}-message\">${htmlEscape(msg.replace(/\\s+at\\s+\\d+$/, ''))}</div>\n    </div>`;\n}\n/**\n * Returns last element in given array\n */\nfunction last$5(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n/**\n * Check if given editor instance has internal Emmet state\n */\nfunction hasInternalState(editor) {\n    return stateKey in editor;\n}\n/**\n * Returns internal Emmet state for given editor instance\n */\nfunction getInternalState(editor) {\n    if (!hasInternalState(editor)) {\n        editor[stateKey] = { id: String(idCounter++) };\n    }\n    return editor[stateKey];\n}\n\nconst xmlSyntaxes = ['xml', 'xsl', 'jsx'];\nconst htmlSyntaxes = ['html', 'htmlmixed', 'vue'];\nconst cssSyntaxes = ['css', 'scss', 'less'];\nconst jsxSyntaxes = ['jsx', 'tsx'];\nconst markupSyntaxes = ['haml', 'jade', 'pug', 'slim'].concat(htmlSyntaxes, xmlSyntaxes, jsxSyntaxes);\nconst stylesheetSyntaxes = ['sass', 'sss', 'stylus', 'postcss'].concat(cssSyntaxes);\n/**\n * Returns Emmet syntax info for given location in view.\n * Syntax info is an abbreviation type (either 'markup' or 'stylesheet') and syntax\n * name, which is used to apply syntax-specific options for output.\n *\n * By default, if given location doesn’t match any known context, this method\n * returns `null`, but if `fallback` argument is provided, it returns data for\n * given fallback syntax\n */\nfunction syntaxInfo(editor, pos) {\n    let syntax = docSyntax(editor);\n    let inline;\n    let context;\n    if (isHTML(syntax)) {\n        const content = getContent(editor);\n        context = getHTMLContext(content, pos, {\n            xml: isXML(syntax)\n        });\n        if (context.css) {\n            // `pos` is in embedded CSS\n            syntax = getEmbeddedStyleSyntax$1(content, context) || 'css';\n            inline = context.css.inline;\n            context = context.css;\n        }\n    }\n    else if (isCSS(syntax)) {\n        context = getCSSContext(getContent(editor), pos);\n    }\n    return {\n        type: getSyntaxType(syntax),\n        syntax,\n        inline,\n        context\n    };\n}\n/**\n * Returns syntax for given position in editor\n */\nfunction syntaxFromPos(editor, pos) {\n    const p = editor.posFromIndex(pos);\n    const mode = editor.getModeAt(p);\n    if (mode && mode.name === 'xml') {\n        // XML mode is used for styling HTML as well\n        return mode.configuration || mode.name;\n    }\n    return mode && mode.name;\n}\n/**\n * Returns main editor syntax\n */\nfunction docSyntax(editor) {\n    const mode = editor.getMode();\n    if (mode) {\n        return mode.name === 'htmlmixed' ? 'html' : (mode.name || '');\n    }\n    return '';\n}\n/**\n * Returns Emmet abbreviation type for given syntax\n */\nfunction getSyntaxType(syntax) {\n    return syntax && stylesheetSyntaxes.includes(syntax) ? 'stylesheet' : 'markup';\n}\n/**\n * Check if given syntax is XML dialect\n */\nfunction isXML(syntax) {\n    return syntax ? xmlSyntaxes.includes(syntax) : false;\n}\n/**\n * Check if given syntax is HTML dialect (including XML)\n */\nfunction isHTML(syntax) {\n    return syntax\n        ? htmlSyntaxes.includes(syntax) || isXML(syntax)\n        : false;\n}\n/**\n * Check if given syntax name is supported by Emmet\n */\nfunction isSupported(syntax) {\n    return syntax\n        ? markupSyntaxes.includes(syntax) || stylesheetSyntaxes.includes(syntax)\n        : false;\n}\n/**\n * Check if given syntax is a CSS dialect. Note that it’s not the same as stylesheet\n * syntax: for example, SASS is a stylesheet but not CSS dialect (but SCSS is)\n */\nfunction isCSS(syntax) {\n    return syntax ? cssSyntaxes.includes(syntax) : false;\n}\n/**\n * Check if given syntax is JSX dialect\n */\nfunction isJSX(syntax) {\n    return syntax ? jsxSyntaxes.includes(syntax) : false;\n}\n/**\n * Check if given option if enabled for specified syntax\n */\nfunction enabledForSyntax(opt, info) {\n    if (opt === true) {\n        return true;\n    }\n    if (Array.isArray(opt)) {\n        const candidates = [info.type, info.syntax];\n        if (info.inline) {\n            candidates.push(`${info.type}-inline`, `${info.syntax}-inline`);\n        }\n        return candidates.some(c => opt.includes(c));\n    }\n    return false;\n}\n/**\n * Returns embedded stylesheet syntax from given HTML context\n */\nfunction getEmbeddedStyleSyntax$1(code, ctx) {\n    const parent = last$5(ctx.ancestors);\n    if (parent && parent.name === 'style') {\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            if (attr.name === 'type') {\n                return attributeValue$2(attr);\n            }\n        }\n    }\n}\n/**\n * Returns context for Emmet abbreviation from given HTML context\n */\nfunction getMarkupAbbreviationContext$1(code, ctx) {\n    const parent = last$5(ctx.ancestors);\n    if (parent) {\n        const attrs = {};\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            attrs[attr.name] = attributeValue$2(attr) || '';\n        }\n        return {\n            name: parent.name,\n            attributes: attrs\n        };\n    }\n}\n/**\n * Returns context for Emmet abbreviation from given CSS context\n */\nfunction getStylesheetAbbreviationContext$1(ctx) {\n    if (ctx.inline) {\n        return { name: \"@@property\" /* Property */ };\n    }\n    const parent = last$5(ctx.ancestors);\n    let scope = \"@@global\" /* Global */;\n    if (ctx.current) {\n        if (ctx.current.type === \"propertyValue\" /* PropertyValue */ && parent) {\n            scope = parent.name;\n        }\n        else if ((ctx.current.type === \"selector\" /* Selector */ || ctx.current.type === \"propertyName\" /* PropertyName */) && !parent) {\n            scope = \"@@section\" /* Section */;\n        }\n    }\n    return {\n        name: scope\n    };\n}\n\nconst nullary = token(\"null\" /* Null */, 0);\n/**\n * Parses given expression in forward direction\n */\nfunction parse$2(expr) {\n    const scanner = typeof expr === 'string' ? new Scanner(expr) : expr;\n    let ch;\n    let priority = 0;\n    let expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n    const tokens = [];\n    while (!scanner.eof()) {\n        scanner.eatWhile(isWhiteSpace);\n        scanner.start = scanner.pos;\n        if (consumeNumber$1(scanner)) {\n            if ((expected & 1 /* Primary */) === 0) {\n                error$2('Unexpected number', scanner);\n            }\n            tokens.push(number(scanner.current()));\n            expected = (2 /* Operator */ | 8 /* RParen */);\n        }\n        else if (isOperator$3(scanner.peek())) {\n            ch = scanner.next();\n            if (isSign(ch) && (expected & 16 /* Sign */)) {\n                if (isNegativeSign(ch)) {\n                    tokens.push(op1(ch, priority));\n                }\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n            else {\n                if ((expected & 2 /* Operator */) === 0) {\n                    error$2('Unexpected operator', scanner);\n                }\n                tokens.push(op2(ch, priority));\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n        }\n        else if (scanner.eat(40 /* LeftParenthesis */)) {\n            if ((expected & 4 /* LParen */) === 0) {\n                error$2('Unexpected \"(\"', scanner);\n            }\n            priority += 10;\n            expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */ | 32 /* NullaryCall */);\n        }\n        else if (scanner.eat(41 /* RightParenthesis */)) {\n            priority -= 10;\n            if (expected & 32 /* NullaryCall */) {\n                tokens.push(nullary);\n            }\n            else if ((expected & 8 /* RParen */) === 0) {\n                error$2('Unexpected \")\"', scanner);\n            }\n            expected = (2 /* Operator */ | 8 /* RParen */ | 4 /* LParen */);\n        }\n        else {\n            error$2('Unknown character', scanner);\n        }\n    }\n    if (priority < 0 || priority >= 10) {\n        error$2('Unmatched \"()\"', scanner);\n    }\n    const result = orderTokens(tokens);\n    if (result === null) {\n        error$2('Parity', scanner);\n    }\n    return result;\n}\n/**\n * Consumes number from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */) && scanner.eatWhile(isNumber)) {\n        // short decimal notation: .025\n        return true;\n    }\n    if (scanner.eatWhile(isNumber) && (!scanner.eat(46 /* Dot */) || scanner.eatWhile(isNumber))) {\n        // either integer or decimal: 10, 10.25\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Orders parsed tokens (operands and operators) in given array so that they are\n * laid off in order of execution\n */\nfunction orderTokens(tokens) {\n    const operators = [];\n    const operands = [];\n    let nOperators = 0;\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n        if (t.type === \"num\" /* Number */) {\n            operands.push(t);\n        }\n        else {\n            nOperators += t.type === \"op1\" /* Op1 */ ? 1 : 2;\n            while (operators.length) {\n                if (t.priority <= operators[operators.length - 1].priority) {\n                    operands.push(operators.pop());\n                }\n                else {\n                    break;\n                }\n            }\n            operators.push(t);\n        }\n    }\n    return nOperators + 1 === operands.length + operators.length\n        ? operands.concat(operators.reverse())\n        : null /* parity */;\n}\n/**\n * Number token factory\n */\nfunction number(value, priority) {\n    return token(\"num\" /* Number */, parseFloat(value), priority);\n}\n/**\n * Unary operator factory\n * @param value    Operator  character code\n * @param priority Operator execution priority\n */\nfunction op1(value, priority = 0) {\n    if (value === 45 /* Minus */) {\n        priority += 2;\n    }\n    return token(\"op1\" /* Op1 */, value, priority);\n}\n/**\n * Binary operator factory\n * @param value Operator  character code\n * @param priority Operator execution priority\n */\nfunction op2(value, priority = 0) {\n    if (value === 42 /* Multiply */) {\n        priority += 1;\n    }\n    else if (value === 47 /* Divide */ || value === 92 /* IntDivide */) {\n        priority += 2;\n    }\n    return token(\"op2\" /* Op2 */, value, priority);\n}\nfunction error$2(name, scanner) {\n    if (scanner) {\n        name += ` at column ${scanner.pos} of expression`;\n    }\n    throw new Error(name);\n}\nfunction isSign(ch) {\n    return isPositiveSign(ch) || isNegativeSign(ch);\n}\nfunction isPositiveSign(ch) {\n    return ch === 43 /* Plus */;\n}\nfunction isNegativeSign(ch) {\n    return ch === 45 /* Minus */;\n}\nfunction isOperator$3(ch) {\n    return ch === 43 /* Plus */ || ch === 45 /* Minus */ || ch === 42 /* Multiply */\n        || ch === 47 /* Divide */ || ch === 92 /* IntDivide */;\n}\nfunction token(type, value, priority = 0) {\n    return { type, value, priority };\n}\n\nconst defaultOptions$2 = {\n    lookAhead: true,\n    whitespace: true\n};\nfunction extract(text, pos = text.length, options) {\n    const opt = Object.assign(Object.assign({}, defaultOptions$2), options);\n    const scanner = { text, pos };\n    let ch;\n    if (opt.lookAhead && cur(scanner) === 41 /* RightParenthesis */) {\n        // Basically, we should consume right parenthesis only with optional whitespace\n        scanner.pos++;\n        const len = text.length;\n        while (scanner.pos < len) {\n            ch = cur(scanner);\n            if (ch !== 41 /* RightParenthesis */ && !(opt.whitespace && isSpace(ch))) {\n                break;\n            }\n            scanner.pos++;\n        }\n    }\n    const end = scanner.pos;\n    let braces = 0;\n    while (scanner.pos >= 0) {\n        if (number$1(scanner)) {\n            continue;\n        }\n        ch = prev(scanner);\n        if (ch === 41 /* RightParenthesis */) {\n            braces++;\n        }\n        else if (ch === 40 /* LeftParenthesis */) {\n            if (!braces) {\n                break;\n            }\n            braces--;\n        }\n        else if (!((opt.whitespace && isSpace(ch)) || isSign(ch) || isOperator$3(ch))) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (scanner.pos !== end && !braces) {\n        // Trim whitespace\n        while (isSpace(cur(scanner))) {\n            scanner.pos++;\n        }\n        return [scanner.pos, end];\n    }\n    return null;\n}\n/**\n * Backward-consumes number from given scanner, if possible\n */\nfunction number$1(scanner) {\n    if (isNumber(prev(scanner))) {\n        scanner.pos--;\n        let dot = false;\n        let ch;\n        while (scanner.pos >= 0) {\n            ch = prev(scanner);\n            if (ch === 46 /* . */) {\n                if (dot) {\n                    // Decimal delimiter already consumed, abort\n                    break;\n                }\n                dot = true;\n            }\n            else if (!isNumber(ch)) {\n                break;\n            }\n            scanner.pos--;\n        }\n        return true;\n    }\n    return false;\n}\nfunction prev(scanner) {\n    return scanner.text.charCodeAt(scanner.pos - 1);\n}\nfunction cur(scanner) {\n    return scanner.text.charCodeAt(scanner.pos);\n}\n\nconst ops1 = {\n    [45 /* Minus */]: num => -num\n};\nconst ops2 = {\n    [43 /* Plus */]: (a, b) => a + b,\n    [45 /* Minus */]: (a, b) => a - b,\n    [42 /* Multiply */]: (a, b) => a * b,\n    [47 /* Divide */]: (a, b) => a / b,\n    [92 /* IntDivide */]: (a, b) => Math.floor(a / b)\n};\n/**\n * Evaluates given math expression\n * @param expr Expression to evaluate\n */\nfunction evaluate(expr) {\n    if (!Array.isArray(expr)) {\n        expr = parse$2(expr);\n    }\n    if (!expr || !expr.length) {\n        return null;\n    }\n    const nStack = [];\n    let n1;\n    let n2;\n    let f;\n    for (let i = 0, il = expr.length; i < il; i++) {\n        const token = expr[i];\n        if (token.type === \"num\" /* Number */) {\n            nStack.push(token.value);\n        }\n        else if (token.type === \"op2\" /* Op2 */) {\n            n2 = nStack.pop();\n            n1 = nStack.pop();\n            f = ops2[token.value];\n            nStack.push(f(n1, n2));\n        }\n        else if (token.type === \"op1\" /* Op1 */) {\n            n1 = nStack.pop();\n            f = ops1[token.value];\n            nStack.push(f(n1));\n        }\n        else {\n            throw new Error('Invalid expression');\n        }\n    }\n    if (nStack.length > 1) {\n        throw new Error('Invalid Expression (parity)');\n    }\n    return nStack[0];\n}\n\nfunction getOutputOptions(editor, pos, inline) {\n    const posObj = pos != null ? editor.posFromIndex(pos) : editor.getCursor();\n    const syntax = docSyntax(editor) || 'html';\n    const config = getEmmetConfig(editor);\n    const opt = {\n        'output.baseIndent': lineIndent(editor, posObj.line),\n        'output.indent': getIndentation(editor),\n        'output.field': field$3(),\n        'output.format': !inline,\n        'output.attributeQuotes': config.attributeQuotes\n    };\n    if (syntax === 'html') {\n        opt['output.selfClosingStyle'] = config.markupStyle;\n        opt['output.compactBoolean'] = config.markupStyle === 'html';\n    }\n    if (isHTML(syntax)) {\n        if (config.comments) {\n            opt['comment.enabled'] = true;\n            if (config.commentsTemplate) {\n                opt['comment.after'] = config.commentsTemplate;\n            }\n        }\n        opt['bem.enabled'] = config.bem;\n        opt['stylesheet.shortHex'] = config.shortHex;\n    }\n    return opt;\n}\n/**\n * Produces tabstop for CodeMirror editor\n */\nfunction field$3() {\n    let handled = false;\n    return (index, placeholder) => {\n        if (!handled) {\n            handled = true;\n            return placeholder\n                ? tabStopStart + placeholder + tabStopEnd\n                : tabStopStart;\n        }\n        return '';\n    };\n}\n/**\n * Returns indentation of given line\n */\nfunction lineIndent(editor, line) {\n    const lineStr = editor.getLine(line);\n    const indent = lineStr.match(/^\\s+/);\n    return indent ? indent[0] : '';\n}\n/**\n * Returns token used for single indentation in given editor\n */\nfunction getIndentation(editor) {\n    if (!editor.getOption('indentWithTabs')) {\n        return ' '.repeat(editor.getOption('indentUnit') || 0);\n    }\n    return '\\t';\n}\n\n/**\n * Cache for storing internal Emmet data.\n * TODO reset whenever user settings are changed\n */\nlet cache = {};\n/**\n * Expands given abbreviation into code snippet\n */\nfunction expand(editor, abbr, config) {\n    let opt = { cache };\n    const outputOpt = {\n        'output.field': field$3(),\n        'output.format': !config || !config['inline'],\n    };\n    if (config) {\n        Object.assign(opt, config);\n        if (config.options) {\n            Object.assign(outputOpt, config.options);\n        }\n    }\n    opt.options = outputOpt;\n    const pluginConfig = getEmmetConfig(editor);\n    if (pluginConfig.config) {\n        opt = resolveConfig(opt, pluginConfig.config);\n    }\n    return expandAbbreviation(abbr, opt);\n}\n/**\n * Extracts abbreviation from given source code by detecting actual syntax context.\n * For example, if host syntax is HTML, it tries to detect if location is inside\n * embedded CSS.\n *\n * It also detects if abbreviation is allowed at given location: HTML tags,\n * CSS selectors may not contain abbreviations.\n * @param code Code from which abbreviation should be extracted\n * @param pos Location at which abbreviation should be expanded\n * @param syntax Syntax of abbreviation to expand\n */\nfunction extract$1(code, pos, type = 'markup', options) {\n    return extractAbbreviation(code, pos, Object.assign({ lookAhead: type !== 'stylesheet', type }, options));\n}\n/**\n * Returns list of tags for balancing for given code\n */\nfunction balance(code, pos, inward = false, xml = false) {\n    const options = { xml };\n    return inward\n        ? balancedInward(code, pos, options)\n        : balancedOutward(code, pos, options);\n}\n/**\n * Returns list of selector/property ranges for balancing for given code\n */\nfunction balanceCSS(code, pos, inward) {\n    return inward\n        ? balancedInward$1(code, pos)\n        : balancedOutward$1(code, pos);\n}\n/**\n * Returns model for selecting next/previous item\n */\nfunction selectItem(code, pos, isCSS, isPrevious) {\n    return isCSS\n        ? selectItemCSS(code, pos, isPrevious)\n        : selectItemHTML(code, pos, isPrevious);\n}\n/**\n * Finds and evaluates math expression at given position in line\n */\nfunction evaluateMath(code, pos, options) {\n    const expr = extract(code, pos, options);\n    if (expr) {\n        try {\n            const [start, end] = expr;\n            const result = evaluate(code.slice(start, end));\n            if (result) {\n                return {\n                    start, end, result,\n                    snippet: result.toFixed(4).replace(/\\.?0+$/, '')\n                };\n            }\n        }\n        catch (err) {\n            console.error(err);\n        }\n    }\n}\n/**\n * Returns matched HTML/XML tag for given point in view\n */\nfunction getTagContext(editor, pos, xml) {\n    const content = getContent(editor);\n    let ctx;\n    if (xml == null) {\n        // Autodetect XML dialect\n        const mode = editor.getMode();\n        xml = mode ? isXML(mode.name) : false;\n    }\n    const matchedTag = match(content, pos, { xml });\n    if (matchedTag) {\n        const { open, close } = matchedTag;\n        ctx = {\n            name: matchedTag.name,\n            open,\n            close\n        };\n        if (matchedTag.attributes) {\n            ctx.attributes = {};\n            matchedTag.attributes.forEach(attr => {\n                let value = attr.value;\n                if (value && isQuotedString$1(value)) {\n                    value = value.slice(1, -1);\n                }\n                ctx.attributes[attr.name] = value == null ? null : value;\n            });\n        }\n    }\n    return ctx;\n}\n/**\n * Returns Emmet options for given character location in editor\n */\nfunction getOptions(editor, pos) {\n    const info = syntaxInfo(editor, pos);\n    const { context } = info;\n    const config = {\n        type: info.type,\n        syntax: info.syntax || 'html',\n        options: getOutputOptions(editor, pos, info.inline)\n    };\n    if (context) {\n        const content = getContent(editor);\n        // Set context from syntax info\n        if (context.type === 'html' && context.ancestors.length) {\n            config.context = getMarkupAbbreviationContext$1(content, context);\n        }\n        else if (context.type === 'css') {\n            config.context = getStylesheetAbbreviationContext$1(context);\n        }\n    }\n    return config;\n}\n\n/** Class name for Emmet abbreviation marker in editor */\nconst markClass = 'emmet-abbreviation';\n/** Class name for Emmet abbreviation preview in editor */\nconst previewClass = 'emmet-abbreviation-preview';\nclass CMEditorProxy {\n    constructor() {\n        this.marker = null;\n        this.preview = null;\n        this.forcedMarker = null;\n    }\n    get id() {\n        return getInternalState(this.cm).id;\n    }\n    substr(from, to) {\n        const value = this.cm.getValue();\n        if (from === undefined && to === undefined) {\n            return value;\n        }\n        return value.slice(from || 0, to);\n    }\n    replace(value, from, to) {\n        this.cm.replaceRange(value, this.cm.posFromIndex(from), this.cm.posFromIndex(to));\n    }\n    syntax() {\n        return docSyntax(this.cm);\n    }\n    size() {\n        return this.cm.getValue().length;\n    }\n    config(pos) {\n        return getOptions(this.cm, pos);\n    }\n    outputOptions(pos, inline) {\n        return getOutputOptions(this.cm, pos, inline);\n    }\n    previewConfig(config) {\n        return Object.assign(Object.assign({}, config), { options: Object.assign(Object.assign({}, config.options), { 'output.field': previewField, 'output.indent': '  ', 'output.baseIndent': '' }) });\n    }\n    allowTracking(pos) {\n        return allowTracking(this.cm, pos);\n    }\n    mark(tracker) {\n        const { cm } = this;\n        this.disposeMarker();\n        const [from, to] = toRange(cm, tracker.range);\n        this.marker = cm.markText(from, to, {\n            inclusiveLeft: true,\n            inclusiveRight: true,\n            clearWhenEmpty: false,\n            className: markClass\n        });\n        if (tracker.forced && !this.forcedMarker) {\n            this.forcedMarker = document.createElement('div');\n            this.forcedMarker.className = `${markClass}-marker`;\n            cm.addWidget(from, this.forcedMarker, false);\n        }\n    }\n    unmark() {\n        this.disposeMarker();\n        this.hidePreview();\n    }\n    showPreview(tracker) {\n        const { cm } = this;\n        const config = getEmmetConfig(cm);\n        // Check if we should display preview\n        if (!enabledForSyntax(config.preview, syntaxInfo(cm, tracker.range[0]))) {\n            return;\n        }\n        let content;\n        let isError = false;\n        if (tracker.type === \"error\" /* Error */) {\n            content = errorSnippet(tracker.error);\n            isError = true;\n        }\n        else if (tracker.forced || !tracker.simple) {\n            content = tracker.preview;\n        }\n        if (content) {\n            if (!this.preview) {\n                const previewElem = document.createElement('div');\n                previewElem.className = previewClass;\n                const pos = cm.posFromIndex(tracker.range[0]);\n                if (config.attachPreview) {\n                    config.attachPreview(cm, previewElem, pos);\n                }\n                else {\n                    cm.addWidget(pos, previewElem, false);\n                }\n                // @ts-ignore\n                this.preview = new this.cm.constructor(previewElem, {\n                    mode: cm.getOption('mode'),\n                    readOnly: 'nocursor',\n                    lineNumbers: false\n                });\n                const errElement = document.createElement('div');\n                errElement.className = `${previewClass}-error`;\n                previewElem.appendChild(errElement);\n            }\n            const wrapper = this.preview.getWrapperElement().parentElement;\n            wrapper.classList.toggle('has-error', isError);\n            if (isError) {\n                wrapper.querySelector(`.${previewClass}-error`).innerHTML = content;\n            }\n            else {\n                this.preview.setValue(content);\n            }\n        }\n        else {\n            this.hidePreview();\n        }\n    }\n    hidePreview() {\n        if (this.preview) {\n            this.preview.getWrapperElement().parentElement.remove();\n            this.preview = null;\n        }\n    }\n    /**\n     * Check if given syntax is a CSS dialect (including SCSS, LESS etc)\n     */\n    isCSS(syntax) {\n        return isCSS(syntax);\n    }\n    syntaxType(syntax) {\n        return getSyntaxType(syntax);\n    }\n    /**\n     * Check if given syntax is a HTML dialect. HTML dialects also support embedded\n     * stylesheets in `<style>` tga or `style=\"\"` attribute\n     */\n    isHTML(syntax) {\n        return isHTML(syntax);\n    }\n    /**\n     * Check if given syntax is a XML dialect. Unlike HTML, XML dialects doesn’t\n     * support embedded stylesheets\n     */\n    isXML(syntax) {\n        return isXML(syntax);\n    }\n    /**\n     * Check if given syntax is a JSX dialect\n     */\n    isJSX(syntax) {\n        return isJSX(syntax);\n    }\n    /**\n     * Runs given callback in context of given editor\n     */\n    run(editor, callback) {\n        const { cm } = this;\n        this.cm = editor;\n        const result = callback();\n        this.cm = cm;\n        return result;\n    }\n    disposeMarker() {\n        if (this.marker) {\n            this.marker.clear();\n            this.marker = null;\n        }\n        if (this.forcedMarker) {\n            this.forcedMarker.remove();\n            this.forcedMarker = null;\n        }\n    }\n}\nfunction previewField(index, placeholder) {\n    return placeholder;\n}\nconst proxy = new CMEditorProxy();\nconst controller = new AbbreviationTrackingController();\nfunction initAbbreviationTracker(editor) {\n    const onChange = (ed) => {\n        proxy.run(ed, () => {\n            controller.handleChange(proxy, getCaret(ed));\n        });\n    };\n    const onSelectionChange = (ed) => {\n        proxy.run(ed, () => {\n            const caret = getCaret(ed);\n            if (!isEnabled(ed, caret)) {\n                return;\n            }\n            const tracker = controller.handleSelectionChange(proxy, caret);\n            if (tracker) {\n                if (contains(tracker, caret)) {\n                    proxy.showPreview(tracker);\n                }\n                else {\n                    proxy.hidePreview();\n                }\n            }\n        });\n    };\n    editor.on('change', onChange);\n    editor.on('focus', onSelectionChange);\n    editor.on('cursorActivity', onSelectionChange);\n    return () => {\n        proxy.run(editor, () => controller.disposeEditor(proxy));\n        editor.off('change', onChange);\n        editor.off('focus', onSelectionChange);\n        editor.off('cursorActivity', onSelectionChange);\n    };\n}\n/**\n * Runs given function in context of abbreviation tracker\n */\nfunction runInTrackerContext(editor, callback) {\n    return proxy.run(editor, () => callback(controller, proxy));\n}\n/**\n * Check if abbreviation tracking is allowed in editor at given location\n */\nfunction allowTracking(editor, pos) {\n    if (isEnabled(editor, pos)) {\n        const syntax = syntaxFromPos(editor, pos);\n        return syntax ? isSupported(syntax) || isJSX(syntax) : false;\n    }\n    return false;\n}\n/**\n * Check if Emmet auto-complete is enabled\n */\nfunction isEnabled(editor, pos) {\n    const config = getEmmetConfig(editor);\n    return enabledForSyntax(config.mark, syntaxInfo(editor, pos));\n}\n/**\n * If allowed, tries to extract abbreviation from given completion context\n */\nfunction extractTracker(editor, pos) {\n    return proxy.run(editor, () => {\n        const syntax = proxy.syntax();\n        const prefix = proxy.isJSX(syntax) ? JSX_PREFIX : '';\n        const config = controller.getActivationContext(proxy, pos);\n        const abbr = extract$1(proxy.substr(), pos, getSyntaxType(config === null || config === void 0 ? void 0 : config.syntax), { prefix });\n        if (abbr) {\n            const tracker = controller.startTracking(proxy, abbr.start, abbr.end, {\n                offset: prefix.length,\n                config\n            });\n            if (tracker) {\n                proxy.showPreview(tracker);\n            }\n            return tracker;\n        }\n    });\n}\n/**\n * Returns abbreviation tracker for given editor, if any\n */\nfunction getTracker(editor) {\n    return proxy.run(editor, () => controller.getTracker(proxy));\n}\n/**\n * Start abbreviation tracking in given editor for given range\n */\nfunction startTracking(editor, start, pos, params) {\n    return proxy.run(editor, () => {\n        const tracker = controller.startTracking(proxy, start, pos, params);\n        if (tracker) {\n            proxy.showPreview(tracker);\n        }\n        return tracker;\n    });\n}\n/**\n * Stops abbreviation tracking in given editor\n */\nfunction stopTracking(editor, params) {\n    return proxy.run(editor, () => controller.stopTracking(proxy, params));\n}\n/**\n * Returns completion item, suitable for auto-hint CodeMirror module,\n * with tracked abbreviation for it\n */\nfunction getCompletion(editor, pos) {\n    const tracker = getTracker(editor) || extractTracker(editor, pos);\n    if (tracker && contains(tracker, pos) && tracker.type === \"abbreviation\" /* Abbreviation */) {\n        const { abbreviation, preview } = tracker;\n        return {\n            text: abbreviation,\n            displayText: preview,\n            hint: () => {\n                stopTracking(editor);\n                const snippet = expand(editor, abbreviation, tracker.config);\n                replaceWithSnippet(editor, tracker.range, snippet);\n            },\n            from: editor.posFromIndex(tracker.range[0]),\n            to: editor.posFromIndex(tracker.range[1]),\n        };\n    }\n}\n/**\n * Restore tracker on undo, if possible\n */\nfunction restoreOnUndo(editor, pos, abbr) {\n    proxy.run(editor, () => {\n        const lastTracker = controller.getStoredTracker(proxy);\n        if (lastTracker) {\n            const shouldRestore = lastTracker.type === \"abbreviation\" /* Abbreviation */\n                && abbr === lastTracker.abbreviation\n                && lastTracker.range[0] === pos;\n            if (shouldRestore) {\n                controller.restoreTracker(proxy, pos);\n            }\n        }\n    });\n}\n/**\n * Check if tracker range contains given position\n */\nfunction contains(tracker, pos) {\n    return pos >= tracker.range[0] && pos <= tracker.range[1];\n}\n\nconst openTagMark = 'emmet-open-tag';\nconst closeTagMark = 'emmet-close-tag';\n/**\n * Setup editor for tag matching\n */\nfunction markTagMatches(editor) {\n    let tags = null;\n    let lastMatch;\n    let tagPreview = null;\n    /**\n     * Displays tag preview as given location, if possible\n     */\n    function showTagPreview(ed, pos, preview) {\n        // Check if we already have preview at given location\n        if (!tagPreview || tagPreview.dataset.pos !== String(pos)) {\n            hidePreview();\n            tagPreview = createPreviewWidget(ed, pos, preview);\n        }\n    }\n    function hidePreview() {\n        if (tagPreview) {\n            tagPreview.remove();\n            tagPreview = null;\n        }\n    }\n    const onCursorActivity = (ed) => {\n        if (!tags) {\n            tags = getTagMatches(ed.getValue());\n        }\n        const caret = getCaret(ed);\n        let match = findTagMatch(tags, caret);\n        if (match) {\n            if (!match.preview) {\n                match.preview = generatePreview(ed, match);\n            }\n            if (shouldDisplayTagPreview(ed, match, caret)) {\n                showTagPreview(ed, match.close[1], match.preview);\n            }\n            else {\n                hidePreview();\n            }\n            // Replace full tag match with name-only match\n            const nLen = match.name.length;\n            match = Object.assign(Object.assign({}, match), { open: [match.open[0] + 1, match.open[0] + 1 + nLen] });\n            if (match.close) {\n                match.close = [match.close[0] + 2, match.close[0] + 2 + nLen];\n            }\n        }\n        if (match && (!lastMatch || !rangesEqual(lastMatch.open, match.open))) {\n            clearTagMarks(ed);\n            markTagMatch(ed, match);\n        }\n        else if (!match && lastMatch) {\n            clearTagMarks(ed);\n        }\n        lastMatch = match;\n    };\n    const onChange = (editor) => {\n        tags = null;\n        if (getEmmetConfig(editor).autoRenameTags) {\n            const { open, close } = getTagMarks(editor);\n            if (open && close) {\n                const cursor = editor.getCursor();\n                const openRange = open.find();\n                const closeRange = close.find();\n                let shouldReset = false;\n                if (containsPos(openRange, cursor)) {\n                    // Update happened inside open tag, update close tag as well\n                    shouldReset = updateTag(editor, openRange, closeRange);\n                }\n                else if (containsPos(closeRange, cursor)) {\n                    // Update happened inside close tag, update open tag as well\n                    shouldReset = updateTag(editor, closeRange, openRange);\n                }\n                if (shouldReset) {\n                    // Reset last match & marker to find and re-mark new location\n                    clearTagMarks(editor);\n                    lastMatch = null;\n                }\n            }\n        }\n    };\n    editor.on('cursorActivity', onCursorActivity);\n    editor.on('change', onChange);\n    return () => {\n        clearTagMarks(editor);\n        hidePreview();\n        editor.off('cursorActivity', onCursorActivity);\n        editor.off('cursorActivity', onChange);\n        tags = lastMatch = null;\n    };\n}\nfunction shouldDisplayTagPreview(editor, match, caret) {\n    return match.close && match.preview && getEmmetConfig(editor).previewOpenTag\n        && caret > match.close[0] && caret < match.close[1];\n}\n/**\n * Marks given tag match in editor\n */\nfunction markTagMatch(editor, { open, close, preview }) {\n    createTagMark(editor, editor.posFromIndex(open[0]), editor.posFromIndex(open[1]), openTagMark);\n    if (close) {\n        createTagMark(editor, editor.posFromIndex(close[0]), editor.posFromIndex(close[1]), closeTagMark);\n    }\n}\n/**\n * Removes any existing tag marks in editor\n */\nfunction clearTagMarks(editor) {\n    const { open, close } = getTagMarks(editor);\n    open && open.clear();\n    close && close.clear();\n}\n/**\n * Returns open and close tag marks in editor, if available\n */\nfunction getTagMarks(editor) {\n    let open;\n    let close;\n    editor.getAllMarks().forEach(mark => {\n        if (mark['className'] === openTagMark) {\n            open = mark;\n        }\n        else if (mark['className'] === closeTagMark) {\n            close = mark;\n        }\n    });\n    return { open, close };\n}\nfunction createTagMark(editor, from, to, className, attributes) {\n    return editor.markText(from, to, {\n        className,\n        inclusiveLeft: true,\n        inclusiveRight: true,\n        clearWhenEmpty: false,\n        // @ts-ignore `attributes` key is supported\n        attributes\n    });\n}\n/**\n * Updates content of `dest` range with valid tag name from `source` range.\n * @returns `true` if tag markers must be updated\n */\nfunction updateTag(editor, source, dest) {\n    const name = editor.getRange(source.from, source.to);\n    const m = name.match(/[\\w:.-]+/);\n    const newName = m ? m[0] : '';\n    if (editor.getRange(dest.from, dest.to) !== newName) {\n        editor.replaceRange(newName, dest.from, dest.to);\n    }\n    return name !== newName;\n}\nfunction createPreviewWidget(editor, pos, preview) {\n    const elem = document.createElement('div');\n    elem.className = 'emmet-tag-preview';\n    elem.innerText = preview;\n    elem.dataset.pos = String(pos);\n    editor.addWidget(editor.posFromIndex(pos), elem, false);\n    return elem;\n}\n/**\n * Generates open tag preview for given tag match\n */\nfunction generatePreview(editor, match) {\n    let className = '';\n    let id = '';\n    const attrs = [];\n    attributes(substr(editor, match.open), match.name).forEach(attr => {\n        if (attr.name === 'class' && attr.value) {\n            className = '.' + unquoted$1(attr.value).replace(/\\s+/g, '.');\n        }\n        else if (attr.name === 'id' && attr.value) {\n            id = '#' + unquoted$1(attr.value);\n        }\n        else {\n            attrs.push(attr.value ? `${attr.name}=${attr.value}` : attr.name);\n        }\n    });\n    const attrString = attrs.length ? `[${attrs.join(' ')}]` : '';\n    const suffix = id + className + attrString;\n    return suffix ? match.name + suffix : '';\n}\nfunction unquoted$1(str) {\n    return isQuotedString$1(str) ? str.slice(1, -1) : str;\n}\n/**\n * Check if given range contains point\n * @param exclude Exclude range end and start\n */\nfunction containsPos(range, pos, exclude) {\n    return exclude\n        ? comparePos(pos, range.from) > 0 && comparePos(pos, range.to) < 0\n        : comparePos(pos, range.from) >= 0 && comparePos(pos, range.to) <= 0;\n}\nfunction comparePos(a, b) {\n    return a.line - b.line || a.ch - b.ch;\n}\n\nfunction error$3(message, scanner) {\n    const err = new Error(message);\n    err.ch = scanner.pos;\n    return err;\n}\nfunction unexpectedCharacter(stream, state, message = 'Unexpected character') {\n    state.parseError = error$3(message.replace(/\\s+at\\s+\\d+$/, ''), stream);\n    stream.skipToEnd();\n    return 'invalidchar';\n}\nfunction last$6(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction emmetAbbreviationMode() {\n    return {\n        startState() {\n            return {\n                attribute: 0,\n                expression: 0,\n                group: 0,\n                quote: 0,\n                braces: [],\n                tokens: [],\n                scanner: new Scanner('')\n            };\n        },\n        token(stream, state) {\n            const { scanner } = state;\n            scanner.string = stream.string;\n            scanner.pos = stream.pos;\n            scanner.start = stream.start;\n            scanner.end = stream.string.length;\n            const ch = scanner.peek();\n            const token = getToken(scanner, state);\n            if (!token) {\n                return unexpectedCharacter(stream, state);\n            }\n            stream.pos = scanner.pos;\n            if (token.type === 'Quote') {\n                state.quote = ch === state.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                if (token.open) {\n                    state[token.context]++;\n                    state.braces.push(token);\n                }\n                else {\n                    state[token.context]--;\n                    const lastBrace = last$6(state.braces);\n                    if (lastBrace && lastBrace.context === token.context) {\n                        state.braces.pop();\n                    }\n                }\n            }\n            // Report if closing braces are missing at the end of abbreviation\n            if (stream.eol() && state.braces.length && !state.parseError) {\n                const pos = last$6(state.braces).start;\n                state.parseError = error$3(`No closing brace at ${pos}`, stream);\n                return null;\n            }\n            const name = getTokenName(token, state);\n            state.tokens.push(token);\n            return name;\n        }\n    };\n}\n/**\n * Returns scope name for given token\n */\nfunction getTokenName(token, state) {\n    const prev = last$6(state.tokens);\n    switch (token.type) {\n        case 'Bracket':\n            return `bracket`;\n        case 'Field':\n            return 'variable-2';\n        case 'Literal':\n            if (state.attribute) {\n                if (prev && prev.type === 'Operator' && prev.operator === 'equal') {\n                    return 'string-2';\n                }\n                return state.quote ? 'string' : 'attribute';\n            }\n            if (state.quote) {\n                return 'string';\n            }\n            if (prev && prev.type === 'Operator') {\n                if (prev.operator === 'class') {\n                    return 'variable-2';\n                }\n                if (prev.operator === 'id') {\n                    return 'variable-3';\n                }\n            }\n            return 'tag';\n        case 'Operator':\n            if (token.operator === 'class') {\n                return 'variable-2';\n            }\n            if (token.operator === 'id') {\n                return 'variable-3';\n            }\n            return `operator ${token.operator}`;\n        case 'Repeater':\n        case 'RepeaterPlaceholder':\n            return 'meta';\n        case 'Quote':\n            return 'string';\n        case 'RepeaterNumber':\n            return 'number';\n    }\n    return '';\n}\n\nfunction emmetAbbreviationMode$1() {\n    return {\n        startState() {\n            return {\n                brackets: 0,\n                tokens: [],\n                scanner: new Scanner('')\n            };\n        },\n        token(stream, state) {\n            const { scanner } = state;\n            scanner.string = stream.string;\n            scanner.pos = stream.pos;\n            scanner.start = stream.start;\n            scanner.end = stream.string.length;\n            const token = getToken$1(scanner, state.brackets === 0);\n            if (!token) {\n                return unexpectedCharacter(stream, state);\n            }\n            if (token.type === 'Bracket') {\n                state.brackets += token.open ? 1 : -1;\n                if (state.brackets < 0) {\n                    return unexpectedCharacter(stream, state, 'Unexpected bracket');\n                }\n            }\n            stream.pos = scanner.pos;\n            const name = getTokenName$1(token);\n            state.tokens.push(token);\n            return name;\n        }\n    };\n}\n/**\n * Returns scope name for given token\n */\nfunction getTokenName$1(token, state) {\n    switch (token.type) {\n        case 'Bracket':\n            return `bracket`;\n        case 'Field':\n            return 'variable-2';\n        case 'Literal':\n            return 'tag';\n        case 'Operator':\n            return `operator ${token.operator}`;\n        case 'ColorValue':\n            return 'variable-3';\n        case 'NumberValue':\n            return 'number';\n        case 'StringValue':\n            return 'string';\n    }\n    return null;\n}\n\n/**\n * Emmet snippet name parsing mode\n */\nfunction snippetNameMode() {\n    return {\n        token(stream) {\n            if (stream.eatWhile(ident$1)) {\n                return 'tag';\n            }\n            if (stream.eat(separator)) {\n                return 'operator';\n            }\n            stream.skipToEnd();\n            return 'invalidchar';\n        }\n    };\n}\nfunction ident$1(ch) {\n    return /[a-zA-Z0-9-_$@!:]/.test(ch);\n}\nfunction separator(ch) {\n    return ch === '|';\n}\n\n// import { getActivationContext } from '../abbreviation';\nfunction expandAbbreviation$1(editor, tabKey) {\n    if (editor.somethingSelected()) {\n        return pass(editor);\n    }\n    if (tabKey) {\n        return expandAbbreviationWithTab(editor);\n    }\n    const caret = getCaret(editor);\n    const pos = editor.posFromIndex(caret);\n    const line = editor.getLine(pos.line);\n    const options = getOptions(editor, caret);\n    const abbr = extract$1(line, pos.ch, getSyntaxType(options.syntax));\n    if (abbr) {\n        const offset = caret - pos.ch;\n        runExpand(editor, abbr.abbreviation, [abbr.start + offset, abbr.end + offset], options);\n    }\n}\nfunction expandAbbreviationWithTab(editor) {\n    // With Tab key, we should either expand tracked abbreviation\n    // or extract abbreviation from current location if abbreviation marking\n    // is not available\n    const caret = getCaret(editor);\n    if (getEmmetConfig(editor).mark) {\n        const tracker = getTracker(editor);\n        if (tracker && contains(tracker, caret) && tracker.type === \"abbreviation\" /* Abbreviation */) {\n            runExpand(editor, tracker.abbreviation, tracker.range, tracker.config);\n            stopTracking(editor, { skipRemove: true });\n            return;\n        }\n        return pass(editor);\n    }\n    return runInTrackerContext(editor, (controller, proxy) => {\n        const options = controller.getActivationContext(proxy, caret);\n        if (options) {\n            const pos = editor.posFromIndex(caret);\n            const line = editor.getLine(pos.line);\n            const abbr = extract$1(line, pos.ch, getSyntaxType(options.syntax));\n            if (abbr) {\n                const offset = caret - pos.ch;\n                runExpand(editor, abbr.abbreviation, [abbr.start + offset, abbr.end + offset], options);\n                return;\n            }\n        }\n        return pass(editor);\n    });\n}\nfunction runExpand(editor, abbr, range, options) {\n    const snippet = expand(editor, abbr, options);\n    replaceWithSnippet(editor, range, snippet);\n}\n\nfunction resetAbbreviation(editor) {\n    const tracker = getTracker(editor);\n    if (tracker) {\n        stopTracking(editor, { force: true });\n    }\n    else {\n        return pass(editor);\n    }\n}\n\nfunction captureAbbreviation(editor) {\n    stopTracking(editor);\n    extractTracker(editor, getCaret(editor));\n}\n\nfunction enterAbbreviationMode(editor) {\n    let tracker = getTracker(editor);\n    stopTracking(editor);\n    if (tracker && tracker.forced) {\n        // Already have forced abbreviation: act as toggler\n        return;\n    }\n    const [from, to] = textRange(editor, editor.listSelections()[0]);\n    tracker = startTracking(editor, from, to, { forced: true });\n    if (from !== to) {\n        editor.setSelection(editor.posFromIndex(to));\n    }\n}\n\nfunction insertLineBreak(editor) {\n    const between = editor.listSelections().map(sel => betweenTags(editor, sel.anchor, sel.head));\n    if (!between.some(Boolean)) {\n        return pass(editor);\n    }\n    editor.operation(() => {\n        const sels = editor.listSelections();\n        // @ts-ignore Invalid docs for Document\n        const nl = editor.getDoc().lineSeparator();\n        const indent = getIndentation(editor);\n        // Step 1: insert newlines either single or double depending on selection\n        const nextSels = [];\n        for (let i = sels.length - 1; i >= 0; i--) {\n            const sel = sels[i];\n            const base = lineIndent(editor, sel.anchor.line);\n            let nextIndent = base;\n            if (between[i]) {\n                nextIndent += indent;\n                editor.replaceRange(nl + nextIndent + nl + base, sel.anchor, sel.head);\n            }\n            else {\n                editor.replaceRange(nl + base, sel.anchor, sel.head);\n            }\n            const nextPos = {\n                line: sel.anchor.line + 1,\n                ch: nextIndent.length\n            };\n            nextSels.unshift({ anchor: nextPos, head: nextPos });\n        }\n        editor.setSelections(nextSels);\n    });\n}\n/**\n * Check if given range is a single caret between tags\n */\nfunction betweenTags(editor, anchor, head) {\n    if (equalCursorPos(anchor, head)) {\n        const mode = editor.getModeAt(anchor);\n        if (mode.name === 'xml') {\n            const left = editor.getTokenAt(anchor);\n            const right = editor.getTokenAt(Object.assign({}, anchor, { ch: anchor.ch + 1 }));\n            return left.type === 'tag bracket' && left.string === '>'\n                && right.type === 'tag bracket' && right.string === '</';\n        }\n    }\n}\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) {\n    return a.line - b.line || a.ch - b.ch;\n}\nfunction equalCursorPos(a, b) {\n    return a.sticky === b.sticky && cmp(a, b) === 0;\n}\n\nconst baseClass = 'emmet-panel';\nconst errClass = 'emmet-error';\nfunction wrapWithAbbreviation(editor) {\n    const syntax = docSyntax(editor);\n    const caret = getCaret(editor);\n    const context = getTagContext(editor, caret, isXML(syntax));\n    const wrapRange = getWrapRange(editor, getSelection(editor), context);\n    const options = getOptions(editor, wrapRange[0]);\n    options.text = getContent$1(editor, wrapRange, true);\n    let panel = createInputPanel();\n    let input = panel.querySelector('input');\n    let errContainer = panel.querySelector(`.${baseClass}-error`);\n    let updated = false;\n    function onInput(evt) {\n        evt && evt.stopPropagation();\n        undo();\n        const abbr = input.value.trim();\n        if (!abbr) {\n            return;\n        }\n        try {\n            const snippet = expand(editor, abbr, options);\n            replaceWithSnippet(editor, wrapRange, snippet);\n            updated = true;\n            if (panel.classList.contains(errClass)) {\n                errContainer.innerHTML = '';\n                panel.classList.remove(errClass);\n            }\n        }\n        catch (err) {\n            updated = false;\n            panel.classList.add(errClass);\n            errContainer.innerHTML = errorSnippet(err);\n            console.error(err);\n        }\n    }\n    function onKeyDown(evt) {\n        if (evt.keyCode === 27 /* ESC */) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            cancel();\n        }\n        else if (evt.keyCode === 13 /* Enter */) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            submit();\n        }\n    }\n    function undo() {\n        if (updated) {\n            editor.undo();\n        }\n    }\n    function cancel() {\n        undo();\n        dispose();\n        editor.focus();\n    }\n    function submit() {\n        // Changes should already be applied to editor\n        dispose();\n        editor.focus();\n    }\n    function dispose() {\n        input.removeEventListener('input', onInput);\n        input.removeEventListener('change', onInput);\n        input.removeEventListener('paste', onInput);\n        input.removeEventListener('keydown', onKeyDown);\n        input.removeEventListener('blur', cancel);\n        panel.remove();\n        // @ts-ignore Dispose element references\n        panel = input = errContainer = null;\n    }\n    // Expose internals to programmatically submit or cancel command\n    panel['emmet'] = { submit, cancel, update: onInput };\n    input.addEventListener('input', onInput);\n    input.addEventListener('change', onInput);\n    input.addEventListener('paste', onInput);\n    input.addEventListener('keydown', onKeyDown);\n    editor.getWrapperElement().appendChild(panel);\n    input.focus();\n}\nfunction createInputPanel() {\n    const elem = document.createElement('div');\n    elem.className = baseClass;\n    elem.innerHTML = `<div class=\"${baseClass}-wrapper\">\n        <input type=\"text\" placeholder=\"Enter abbreviation\" autofocus />\n        <div class=\"${baseClass}-error\"></div>\n    </div>`;\n    return elem;\n}\nfunction getWrapRange(editor, range, context) {\n    if (range[0] === range[1] && context) {\n        // No selection means user wants to wrap current tag container\n        const { open, close } = context;\n        const pos = range[0];\n        // Check how given point relates to matched tag:\n        // if it's in either open or close tag, we should wrap tag itself,\n        // otherwise we should wrap its contents\n        if (inRange(open, pos) || (close && inRange(close, pos))) {\n            return [open[0], close ? close[1] : open[1]];\n        }\n        if (close) {\n            return narrowToNonSpace(editor, [open[1], close[0]]);\n        }\n    }\n    return range;\n}\n/**\n * Returns contents of given region, properly de-indented\n */\nfunction getContent$1(editor, range, lines = false) {\n    const pos = editor.posFromIndex(range[0]);\n    const baseIndent = lineIndent(editor, pos.line);\n    const srcLines = substr(editor, range).split('\\n');\n    const destLines = srcLines.map(line => {\n        return line.startsWith(baseIndent)\n            ? line.slice(baseIndent.length)\n            : line;\n    });\n    return lines ? destLines : destLines.join('\\n');\n}\nfunction inRange(range, pt) {\n    return range[0] < pt && pt < range[1];\n}\nfunction getSelection(editor) {\n    return textRange(editor, editor.listSelections()[0]);\n}\n\nfunction balanceAction(editor, inward) {\n    const syntax = docSyntax(editor);\n    if (isHTML(syntax) || isCSS(syntax)) {\n        const ranges = inward\n            ? balanceActionInward(editor, syntax)\n            : balanceActionOutward(editor, syntax);\n        editor.setSelections(ranges.map(r => ({\n            anchor: editor.posFromIndex(r[0]),\n            head: editor.posFromIndex(r[1]),\n        })));\n    }\n    else {\n        return pass(editor);\n    }\n}\n/**\n * Pushes given `range` into `ranges` list on if it’s not the same as last one\n */\nfunction pushRange$1(ranges, range) {\n    const last = ranges[ranges.length - 1];\n    if (!last || !rangesEqual(last, range)) {\n        ranges.push(range);\n    }\n}\n/**\n * Returns regions for balancing\n */\nfunction getRanges(editor, pos, syntax, inward) {\n    const content = getContent(editor);\n    if (isCSS(syntax)) {\n        return balanceCSS(content, pos, inward);\n    }\n    const result = [];\n    const tags = balance(content, pos, inward, isXML(syntax));\n    for (const tag of tags) {\n        if (tag.close) {\n            // Inner range\n            pushRange$1(result, [tag.open[1], tag.close[0]]);\n            // Outer range\n            pushRange$1(result, [tag.open[0], tag.close[1]]);\n        }\n        else {\n            pushRange$1(result, [tag.open[0], tag.open[1]]);\n        }\n    }\n    return result.sort((a, b) => {\n        return inward ? a[0] - b[0] : b[0] - a[0];\n    });\n}\n/**\n * Returns inward balanced ranges from current view's selection\n */\nfunction balanceActionInward(editor, syntax) {\n    const result = [];\n    for (const sel of editor.listSelections()) {\n        const selRange = textRange(editor, sel);\n        const ranges = getRanges(editor, selRange[0], syntax, true);\n        // Try to find range which equals to selection: we should pick leftmost\n        let ix = ranges.findIndex(r => rangesEqual(selRange, r));\n        let targetRange;\n        if (ix < ranges.length - 1) {\n            targetRange = ranges[ix + 1];\n        }\n        else if (ix !== -1) {\n            // No match found, pick closest region\n            targetRange = ranges.find(r => rangeContains(r, selRange));\n        }\n        result.push(targetRange || selRange);\n    }\n    return result;\n}\n/**\n * Returns outward balanced ranges from current view's selection\n */\nfunction balanceActionOutward(editor, syntax) {\n    const result = [];\n    for (const sel of editor.listSelections()) {\n        const selRange = textRange(editor, sel);\n        const ranges = getRanges(editor, selRange[0], syntax);\n        const targetRange = ranges.find(r => rangeContains(r, selRange) && r[1] > selRange[1]);\n        result.push(targetRange || selRange);\n    }\n    return result;\n}\n\nconst htmlComment = ['<!--', '-->'];\nconst cssComment = ['/*', '*/'];\nfunction comment$2(editor) {\n    const selection = editor.listSelections().slice().reverse();\n    editor.operation(() => {\n        for (const sel of selection) {\n            const selRange = textRange(editor, sel);\n            const { syntax } = syntaxInfo(editor, selRange[0]);\n            const tokens = syntax && isCSS(syntax) ? cssComment : htmlComment;\n            const block = getRangeForComment(editor, selRange[0]);\n            if (block && block.commentStart) {\n                // Caret inside comment, strip it\n                removeComment(editor, block);\n            }\n            else if (block && rangeEmpty(selRange)) {\n                // Wrap block with comments but remove inner comments first\n                let removed = 0;\n                for (const c of getCommentRegions(editor, block.range, tokens).reverse()) {\n                    removed += removeComment(editor, c);\n                }\n                addComment(editor, [block.range[0], block.range[1] - removed], tokens);\n            }\n            else if (!rangeEmpty(selRange)) {\n                // No matching block, comment selection\n                addComment(editor, selRange, tokens);\n            }\n            else {\n                // No matching block, comment line\n                const line = editor.getLine(sel.anchor.line);\n                const lineRange = textRange(editor, {\n                    anchor: { line: sel.anchor.line, ch: 0 },\n                    head: { line: sel.anchor.line, ch: line.length },\n                });\n                addComment(editor, narrowToNonSpace(editor, lineRange), tokens);\n            }\n        }\n    });\n}\n/**\n * Removes comment markers from given region. Returns amount of characters removed\n */\nfunction removeComment(editor, { range, commentStart, commentEnd }) {\n    const text = substr(editor, range);\n    if (commentStart && text.startsWith(commentStart)) {\n        let startOffset = commentStart.length;\n        let endOffset = commentEnd && text.endsWith(commentEnd)\n            ? commentEnd.length\n            : 0;\n        // Narrow down offsets for whitespace\n        if (isSpace$2(text[startOffset])) {\n            startOffset += 1;\n        }\n        if (endOffset && isSpace$2(text[text.length - endOffset - 1])) {\n            endOffset += 1;\n        }\n        const r1 = toRange(editor, [range[1] - endOffset, range[1]]);\n        const r2 = toRange(editor, [range[0], range[0] + startOffset]);\n        editor.replaceRange('', r1[0], r1[1]);\n        editor.replaceRange('', r2[0], r2[1]);\n        return startOffset + endOffset;\n    }\n    return 0;\n}\n/**\n * Adds comments around given range\n */\nfunction addComment(editor, range, tokens) {\n    const [from, to] = toRange(editor, range);\n    editor.replaceRange(' ' + tokens[1], to, to);\n    editor.replaceRange(tokens[0] + ' ', from, from);\n}\n/**\n * Finds comments inside given region and returns their regions\n */\nfunction getCommentRegions(editor, range, tokens) {\n    const result = [];\n    const text = substr(editor, range);\n    let start = range[0];\n    let offset = 0;\n    while (true) {\n        const commentStart = text.indexOf(tokens[0], offset);\n        if (commentStart !== -1) {\n            offset = commentStart + tokens[0].length;\n            // Find comment end\n            const commentEnd = text.indexOf(tokens[1], offset);\n            if (commentEnd !== -1) {\n                offset = commentEnd + tokens[1].length;\n                result.push({\n                    range: [start + commentStart, start + offset],\n                    commentStart: tokens[0],\n                    commentEnd: tokens[1],\n                });\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\nfunction getRangeForComment(editor, pos) {\n    const { syntax } = syntaxInfo(editor, pos);\n    if (!syntax) {\n        return;\n    }\n    if (isHTML(syntax)) {\n        return getHTMLBlockRange(getContent(editor), pos, isXML(syntax));\n    }\n    if (isCSS(syntax)) {\n        const content = getContent(editor);\n        const comment = findCSSComment(content, pos);\n        if (comment) {\n            return comment;\n        }\n        const css = match$1(content, pos);\n        if (css) {\n            return {\n                range: [css.start, css.end]\n            };\n        }\n    }\n}\n/**\n * Returns range for comment toggling\n */\nfunction getHTMLBlockRange(source, pos, xml = false) {\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool = [];\n    const stack = [];\n    const options = createOptions({ xml, allTokens: true });\n    let result;\n    scan(source, (name, type, start, end) => {\n        if (type === 1 /* Open */ && isSelfClose$2(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = 3 /* SelfClose */;\n        }\n        if (type === 1 /* Open */) {\n            // Allocate tag object from pool\n            stack.push(allocTag$1(pool, name, start, end));\n        }\n        else if (type === 3 /* SelfClose */) {\n            if (start < pos && pos < end) {\n                // Matched given self-closing tag\n                result = { range: [start, end] };\n                return false;\n            }\n        }\n        else if (type === 2 /* Close */) {\n            const tag = last$7(stack);\n            if (tag && tag.name === name) {\n                // Matching closing tag found\n                if (tag.start < pos && pos < end) {\n                    result = {\n                        range: [tag.start, end],\n                    };\n                    return false;\n                }\n                else if (stack.length) {\n                    // Release tag object for further re-use\n                    releaseTag$1(pool, stack.pop());\n                }\n            }\n        }\n        else if (start < pos && pos < end) {\n            // Found other token that matches given location\n            result = { range: [start, end] };\n            if (type === 6 /* Comment */) {\n                result.commentStart = htmlComment[0];\n                result.commentEnd = htmlComment[1];\n            }\n            return false;\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * If given `pos` location is inside CSS comment in given `code`, returns its\n * range\n */\nfunction findCSSComment(code, pos) {\n    const scanner = new Scanner(code);\n    while (!scanner.eof() && pos > scanner.pos) {\n        const start = scanner.pos;\n        if (consumeSeq2(scanner, 47 /* Slash */, 42 /* Asterisk */)) {\n            // Consumed multiline comment start\n            while (!scanner.eof() && !consumeSeq2(scanner, 42 /* Asterisk */, 47 /* Slash */)) {\n                scanner.pos++;\n            }\n            if (start < pos && pos < scanner.pos) {\n                return {\n                    range: [start, scanner.pos],\n                    commentStart: cssComment[0],\n                    commentEnd: cssComment[1],\n                };\n            }\n        }\n        else if (consumeSeq2(scanner, 47 /* Slash */, 47 /* Slash */)) {\n            // Consumed single-line comment\n            while (!scanner.eof() && !scanner.eat(13 /* CR */) && !scanner.eat(10 /* LF */)) {\n                scanner.pos++;\n            }\n            if (start < pos && pos < scanner.pos) {\n                return {\n                    range: [start, scanner.pos],\n                    commentStart: '//',\n                };\n            }\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n}\n/**\n * Returns `true` if both `ch1` and `ch2` where consumed\n */\nfunction consumeSeq2(scanner, ch1, ch2) {\n    const { pos } = scanner;\n    if (scanner.eat(ch1) && scanner.eat(ch2)) {\n        return true;\n    }\n    scanner.pos = pos;\n    return false;\n}\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose$2(name, options) {\n    return !options.xml && options.empty.includes(name);\n}\nfunction allocTag$1(pool, name, start, end) {\n    if (pool.length) {\n        const tag = pool.pop();\n        tag.name = name;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, start, end };\n}\nfunction releaseTag$1(pool, tag) {\n    pool.push(tag);\n}\nfunction last$7(arr) {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n\nfunction evaluateMathCommand(editor) {\n    const cursor = editor.getCursor();\n    const line = editor.getLine(cursor.line);\n    const expr = evaluateMath(line, cursor.ch);\n    if (expr) {\n        const from = { line: cursor.line, ch: expr.start };\n        const to = { line: cursor.line, ch: expr.end };\n        editor.replaceRange(expr.snippet, from, to);\n    }\n}\n\nfunction goToEditPoint(editor, inc) {\n    const caret = getCaret(editor);\n    const pos = findNewEditPoint(editor, caret + inc, inc);\n    if (pos != null) {\n        editor.setCursor(editor.posFromIndex(pos));\n    }\n}\nfunction findNewEditPoint(editor, pos, inc) {\n    const doc = getContent(editor);\n    const docSize = doc.length;\n    let curPos = pos;\n    while (curPos < docSize && curPos >= 0) {\n        curPos += inc;\n        const cur = doc[curPos];\n        const next = doc[curPos + 1];\n        const prev = doc[curPos - 1];\n        if (isQuote$4(cur) && next === cur && prev === '=') {\n            // Empty attribute value\n            return curPos + 1;\n        }\n        if (cur === '<' && prev === '>') {\n            // Between tags\n            return curPos;\n        }\n        if (isNewLine(cur)) {\n            const pt = editor.posFromIndex(curPos);\n            const line = editor.getLine(pt.line);\n            if (!line || isSpace$2(line)) {\n                // Empty line\n                return editor.indexFromPos({\n                    line: pt.line,\n                    ch: line.length\n                });\n            }\n        }\n    }\n}\nfunction isNewLine(ch) {\n    return ch === '\\r' || ch === '\\n';\n}\n\nfunction goToTagPair(editor) {\n    let caret = getCaret(editor);\n    const nextRange = [caret, Math.min(caret + 1, editor.getValue().length)];\n    if (substr(editor, nextRange) === '<') {\n        caret++;\n    }\n    const { syntax } = syntaxInfo(editor, caret);\n    if (isHTML(syntax)) {\n        const ctx = getTagContext(editor, caret, isXML(syntax));\n        if (ctx && ctx.open && ctx.close) {\n            const { open, close } = ctx;\n            const nextPos = open[0] <= caret && caret < open[1]\n                ? close[0]\n                : open[0];\n            editor.setCursor(editor.posFromIndex(nextPos));\n        }\n    }\n}\n\nfunction incrementNumber(editor, delta = 1) {\n    editor.operation(() => {\n        const nextRanges = editor.listSelections().slice().reverse().map(sel => {\n            let selRange = textRange(editor, sel);\n            if (rangeEmpty(selRange)) {\n                // No selection, extract number\n                const line = editor.getLine(sel.anchor.line);\n                const offset = sel.anchor.ch;\n                const numRange = extractNumber(line, offset);\n                if (numRange) {\n                    selRange = [\n                        selRange[0] - offset + numRange[0],\n                        selRange[0] - offset + numRange[1],\n                    ];\n                }\n            }\n            if (!rangeEmpty(selRange)) {\n                // Try to update value in given region\n                let value = updateNumber(substr(editor, selRange), delta);\n                replaceWithSnippet(editor, selRange, value);\n                sel = {\n                    anchor: editor.posFromIndex(selRange[0]),\n                    head: editor.posFromIndex(selRange[0] + value.length)\n                };\n            }\n            return sel;\n        });\n        editor.setSelections(nextRanges);\n    });\n}\n/**\n * Extracts number from text at given location\n */\nfunction extractNumber(text, pos) {\n    let hasDot = false;\n    let end = pos;\n    let start = pos;\n    let ch;\n    const len = text.length;\n    // Read ahead for possible numbers\n    while (end < len) {\n        ch = text.charCodeAt(end);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        }\n        else if (!isNumber(ch)) {\n            break;\n        }\n        end++;\n    }\n    // Read backward for possible numerics\n    while (start >= 0) {\n        ch = text.charCodeAt(start - 1);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        }\n        else if (!isNumber(ch)) {\n            break;\n        }\n        start--;\n    }\n    // Negative number?\n    if (start > 0 && text[start - 1] === '-') {\n        start--;\n    }\n    if (start !== end) {\n        return [start, end];\n    }\n}\nfunction updateNumber(num, delta, precision = 3) {\n    const value = parseFloat(num) + delta;\n    if (isNaN(value)) {\n        return num;\n    }\n    const neg = value < 0;\n    let result = Math.abs(value).toFixed(precision);\n    // Trim trailing zeroes and optionally decimal number\n    result = result.replace(/\\.?0+$/, '');\n    // Trim leading zero if input value doesn't have it\n    if ((num[0] === '.' || num.startsWith('-.')) && result[0] === '0') {\n        result = result.slice(1);\n    }\n    return (neg ? '-' : '') + result;\n}\nfunction isDot(ch) {\n    return ch === 46;\n}\n\nfunction removeTagCommand(editor) {\n    editor.operation(() => {\n        const nextRanges = editor.listSelections().slice().reverse().map(sel => {\n            const tag = getTagContext(editor, editor.indexFromPos(sel.anchor));\n            if (tag) {\n                removeTag(editor, tag);\n                const pos = editor.posFromIndex(tag.open[0]);\n                return {\n                    anchor: pos,\n                    head: pos\n                };\n            }\n            return sel;\n        });\n        editor.setSelections(nextRanges);\n    });\n}\nfunction removeTag(editor, { open, close }) {\n    if (close) {\n        // Remove open and close tag and dedent inner content\n        const innerRange = narrowToNonSpace(editor, [open[1], close[0]]);\n        if (!rangeEmpty(innerRange)) {\n            // Gracefully remove open and close tags and tweak indentation on tag contents\n            replaceWithSnippet(editor, [innerRange[1], close[1]], '');\n            const start = editor.posFromIndex(open[0]);\n            const end = editor.posFromIndex(close[1]);\n            if (start.line !== end.line) {\n                // Skip two lines: first one for open tag, on second one\n                // indentation will be removed with open tag\n                let line = start.line + 2;\n                const baseIndent = getLineIndent(editor, open[0]);\n                const innerIndent = getLineIndent(editor, innerRange[0]);\n                while (line <= end.line) {\n                    const lineStart = editor.indexFromPos({ line, ch: 0 });\n                    const indentRange = [lineStart, lineStart + innerIndent.length];\n                    if (isSpace$2(substr(editor, indentRange))) {\n                        console.log('replace \"%s\" with \"%s\"', substr(editor, indentRange), baseIndent);\n                        replaceWithSnippet(editor, indentRange, baseIndent);\n                    }\n                    line++;\n                }\n            }\n            replaceWithSnippet(editor, [open[0], innerRange[0]], '');\n        }\n        else {\n            replaceWithSnippet(editor, [open[0], close[1]], '');\n        }\n    }\n    else {\n        replaceWithSnippet(editor, open, '');\n    }\n}\n/**\n * Returns indentation for line found from given character location\n */\nfunction getLineIndent(editor, ix) {\n    return lineIndent(editor, editor.posFromIndex(ix).line);\n}\n\nfunction selectItemCommand(editor, isPrev = false) {\n    const syntax = docSyntax(editor);\n    if (!isCSS(syntax) && !isHTML(syntax)) {\n        return;\n    }\n    const sel = editor.listSelections()[0];\n    const selRange = textRange(editor, sel);\n    const code = getContent(editor);\n    let model = selectItem(code, selRange[0], isCSS(syntax), isPrev);\n    if (model) {\n        let range = findRange(selRange, model.ranges, isPrev);\n        if (!range) {\n            // Out of available selection range, move to next item\n            const nextPos = isPrev ? model.start : model.end;\n            model = selectItem(code, nextPos, isCSS(syntax), isPrev);\n            if (model) {\n                range = findRange(selRange, model.ranges, isPrev);\n            }\n        }\n        if (range) {\n            const [from, to] = toRange(editor, range);\n            editor.setSelection(from, to);\n        }\n    }\n}\nfunction findRange(sel, ranges, reverse = false) {\n    if (reverse) {\n        ranges = ranges.slice().reverse();\n    }\n    let getNext = false;\n    let candidate;\n    for (const r of ranges) {\n        if (getNext) {\n            return r;\n        }\n        if (rangesEqual(r, sel)) {\n            // This range is currently selected, request next\n            getNext = true;\n        }\n        else if (!candidate && (rangeContains(r, sel) || (reverse && r[0] <= sel[0]) || (!reverse && r[0] >= sel[0]))) {\n            candidate = r;\n        }\n    }\n    if (!getNext) {\n        return candidate;\n    }\n}\n\nfunction splitJoinTag(editor) {\n    const selections = editor.listSelections().slice().reverse();\n    const nextRanges = [];\n    editor.operation(() => {\n        for (const sel of selections) {\n            const pos = editor.indexFromPos(sel.anchor);\n            const { syntax } = syntaxInfo(editor, pos);\n            const tag = getTagContext(editor, pos, isXML(syntax));\n            if (tag) {\n                const { open, close } = tag;\n                if (close) {\n                    // Join tag: remove tag contents, if any, and add closing slash\n                    replaceWithSnippet(editor, [open[1], close[1]], '');\n                    let closing = isSpace$2(getChar(editor, open[1] - 2)) ? '/' : ' /';\n                    replaceWithSnippet(editor, [open[1] - 1, open[1] - 1], closing);\n                    nextRanges.push(createRange(editor, open[1] + closing.length));\n                }\n                else {\n                    // Split tag: add closing part and remove closing slash\n                    const endTag = `</${tag.name}>`;\n                    replaceWithSnippet(editor, [open[1], open[1]], endTag);\n                    if (getChar(editor, open[1] - 2) === '/') {\n                        let start = open[1] - 2;\n                        let end = open[1] - 1;\n                        if (isSpace$2(getChar(editor, start - 1))) {\n                            start--;\n                        }\n                        replaceWithSnippet(editor, [start, end], '');\n                        nextRanges.push(createRange(editor, open[1] - end + start));\n                    }\n                    else {\n                        nextRanges.push(createRange(editor, open[1]));\n                    }\n                }\n            }\n            else {\n                nextRanges.push(sel);\n            }\n        }\n        editor.setSelections(nextRanges);\n    });\n}\nfunction getChar(editor, pos) {\n    return substr(editor, [pos, pos + 1]);\n}\nfunction createRange(editor, pos) {\n    const p = editor.posFromIndex(pos);\n    return {\n        anchor: p,\n        head: p\n    };\n}\n\n/**\n * Registers Emmet extension on given CodeMirror constructor.\n * This file is designed to be imported somehow into the app (CommonJS, ES6,\n * Rollup/Webpack/whatever). If you simply want to add a <script> into your page\n * that registers Emmet extension on global CodeMirror constructor, use\n * `browser.js` instead\n */\nfunction registerEmmetExtension(CM) {\n    // Register Emmet commands\n    Object.assign(CM.commands, {\n        emmetExpandAbbreviation: (editor) => expandAbbreviation$1(editor, true),\n        emmetExpandAbbreviationAll: (editor) => expandAbbreviation$1(editor, false),\n        emmetCaptureAbbreviation: captureAbbreviation,\n        emmetResetAbbreviation: resetAbbreviation,\n        emmetEnterAbbreviationMode: enterAbbreviationMode,\n        emmetInsertLineBreak: insertLineBreak,\n        emmetWrapWithAbbreviation: wrapWithAbbreviation,\n        emmetBalance: balanceAction,\n        emmetBalanceInward: (editor) => balanceAction(editor, true),\n        emmetToggleComment: comment$2,\n        emmetEvaluateMath: evaluateMathCommand,\n        emmetGoToNextEditPoint: (editor) => goToEditPoint(editor, 1),\n        emmetGoToPreviousEditPoint: (editor) => goToEditPoint(editor, -1),\n        emmetGoToTagPair: goToTagPair,\n        emmetIncrementNumber1: (editor) => incrementNumber(editor, 1),\n        emmetIncrementNumber01: (editor) => incrementNumber(editor, .1),\n        emmetIncrementNumber10: (editor) => incrementNumber(editor, 10),\n        emmetDecrementNumber1: (editor) => incrementNumber(editor, -1),\n        emmetDecrementNumber01: (editor) => incrementNumber(editor, -.1),\n        emmetDecrementNumber10: (editor) => incrementNumber(editor, -10),\n        emmetRemoveTag: removeTagCommand,\n        emmetSelectNextItem: (editor) => selectItemCommand(editor),\n        emmetSelectPreviousItem: (editor) => selectItemCommand(editor, true),\n        emmetSplitJoinTag: splitJoinTag,\n    });\n    // Track options change\n    CM.defineOption('emmet', defaultConfig, (editor, value) => {\n        if (!hasInternalState(editor)) {\n            editor.on('change', undoTracker);\n            editor.on('change', pasteTracker);\n        }\n        const state = getInternalState(editor);\n        value = getEmmetConfig(editor, value);\n        if (value.mark && !state.tracker) {\n            state.tracker = initAbbreviationTracker(editor);\n        }\n        else if (!value.mark && state.tracker) {\n            state.tracker();\n            state.tracker = null;\n        }\n        if (value.markTagPairs && !state.tagMatch) {\n            state.tagMatch = markTagMatches(editor);\n        }\n        else if (!value.markTagPairs && state.tagMatch) {\n            state.tagMatch();\n            state.tagMatch = null;\n        }\n    });\n    CM.defineMode('emmet-abbreviation', emmetAbbreviationMode);\n    CM.defineMode('emmet-css-abbreviation', emmetAbbreviationMode$1);\n    CM.defineMode('emmet-snippet', snippetNameMode);\n    // Expose `expandAbbreviation` method to all instances to allow\n    // programmatic usage based on current Emmet options\n    CM.defineExtension('expandAbbreviation', function (abbr, options = getOptions(this, 0)) {\n        return expand(this, abbr, options);\n    });\n    CM.defineExtension('emmetOptions', function (pos = 0) {\n        return getOptions(this, pos);\n    });\n    CM.defineExtension('parseAbbreviation', function (abbr, type) {\n        if (type === 'stylesheet') {\n            return parser(tokenize$1(abbr));\n        }\n        else {\n            return abbreviation(tokenize(abbr), { jsx: type === 'jsx' });\n        }\n    });\n    CM.defineExtension('getEmmetCompletion', function (pos) {\n        if (typeof pos !== 'number') {\n            pos = this.indexFromPos(pos);\n        }\n        return getCompletion(this, pos);\n    });\n}\n/**\n * Undo tracker, if possible\n */\nfunction undoTracker(editor, change) {\n    if (change.origin === 'undo' && change.text.length === 1) {\n        const pos = editor.indexFromPos(change.from);\n        const abbr = change.text[0];\n        restoreOnUndo(editor, pos, abbr);\n    }\n}\n/**\n * Capture abbreviation on paste, if possible\n */\nfunction pasteTracker(editor, change) {\n    if (change.origin === 'paste' && change.text.length === 1 && allowTracking(editor, editor.indexFromPos(change.from))) {\n        // Try to capture abbreviation on paste\n        const pos = editor.indexFromPos(change.from) + change.text[0].length;\n        extractTracker(editor, pos);\n    }\n}\n\nexport default registerEmmetExtension;\n//# sourceMappingURL=extension.es.js.map\n"],"names":["defaultQuotedOptions","escape","throws","code2","from","to","isNumber","isAlphaWord","isAlpha","isWhiteSpace","stream","options","Object","assign","start","pos","quote2","peek","eat","isQuote","eof","next","error","open","close","ch","stack","eatQuoted","String","fromCharCode","[object Object]","str","end","length","string","this","Scanner","charCodeAt","match2","ok","n","substring","slice","message","ScannerError","Error","scanner","tokens","size","test","token2","err","abbr","result","statements","readable","type","elements","node","ctx","element","group","push","consume","isChildOperator","isSiblingOperator","isClimbOperator","pop","isGroupStart","isBracket","repeat","isRepeater","repeater","attr","elem","name","attributes","value","selfClose","jsx","isCapitalizedLiteral","isClassNameOperator","isElementName","elementName","isEmpty","text","getText","shortAttribute","attributeSet","isCloseOperator","concat","Array","isArray","isAttributeSetStart","attributes2","attribute","isAttributeSetEnd","isWhiteSpace$1","isOperator","expression","literal","quoted","isEquals","isQuote$1","single","allowBrackets","brackets","context","isTextStart","isOpen","Boolean","operator","isSingle","isLiteral","source","quote","getToken","index","eatWhile","Number","current","consumePlaceholder","field","repeaterPlaceholder","reverse","base","parent","repeaterNumber","count","implicit","repeater$1","isSpace","whiteSpace","escaped","isAllowedOperator","isElementName$1","isAllowedSpace","isAllowedRepeater","bracketType","literal$1","op","operatorType","isOpenBracket","bracket","isAlphaNumericWord","operators","child","class","climb","id","equal","sibling","tokenVisitor","Literal","Quote","Bracket","Operator","Field","state","getVariable","repeater2","i","repeaters","inserted","lastIx","parentIx","Math","max","parentRepeater","WhiteSpace","original","items","isGroup","convertGroup","convertElement","target","last","deepest","deepestNode","repeatGuard","children","stringifyName","stringifyValue","selfClosing","convertStatement","convertAttribute","some","isField","item","attachRepeater","implied","isBoolean","valueType","shift","boolean","stringify","arr","text2","textInserted","maxRepeat","POSITIVE_INFINITY","join","varValue","variables","convert","abbreviation","tokenize","isValue2","getToken$1","shouldConsumeDashAfter","operator$1","short","consumePlaceholder$1","field$1","afterNegative","hasDecimal","prevPos","hasFloat","consumeNumber","rawValue","unit","numberValue","valueStart","color2","alpha","isHex","colorAlpha","r","g","b","a","parseInt","parseColor","raw","createLiteral$1","colorValue","finished","stringValue","bracket$1","whiteSpace$1","isIdentPrefix","isKeyword","isLiteral$1","literal$2","peek$1","tokenScanner$1","property2","readable$1","consumeProperty","consume$1","isSiblingOperator$1","error$1","valueFragment","important","valueMode","isLiteral$1$1","t1","t2","isFunctionStart","isValueDelimiter","isWhiteSpace$2","isImportant","consumeValue","isFragmentDelimiter","inArgument","args","isValue","consumeArguments","arguments","isOpenBracket$1","isCloseBracket","isArgumentDelimiter","isBracket$1$1","operator2","isOperator$1","parser","tokenize$1","defaultConfig","mark","preview","autoRenameTags","markTagPairs","previewOpenTag","attributeQuotes","markupStyle","comments","commentsTemplate","bem","editor","opt2","getOption","defaultOptions","xml","allTokens","special","style","script","empty","opt","split","map","codes","allowUnclosed","consumeArray","nameStartChar","nameChar","isNaN","isTerminator","eatPair","src","attributeName","nameStart","nameEnd","attributeValue","valueEnd","consumePaired","ident","isUnquoted","unquoted","cdataOpen","toCharCodes","cdataClose","commentOpen","commentClose","piStart","piEnd","erbStart","erbEnd","callback","nameCodes","found","piName","cdata","comment","erb","processingInstruction","isSpecial","consumeClosing","consumeSection","typeValues","attrs","includes","getAttributeValue","pool","tag","forEach","propertyStart","propertyEnd","propertyDelimiter","blockEnd","notify","delimiter","comment$1","whitespace","isKnownSelectorColon","literal$3","operators$1","offset","isOperator$2","isMinusOperator","pendingProperty","alloc","range","firstChild","release","releasePending","inner","innerRange","last$3","ranges","prev2","next2","glue","t","dest","config","resolve","resolved","findDeepest","isNode","walkResolve","level","line","column","processText","lines","il","indent","baseIndent","placeholder","field2","strCase","toLowerCase","inlineElements","isInline","toUpperCase","elementMap","p","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","ancestors","getParentElement","contextName","parentName","vocabularies","ru","common","words","sp","latin","reLorem","floor","random","len","iterations","min","rand","word","val","hasComma","totalCommas","dict","wordCount","startWithCommon","totalWords","sentence","insertCommas","sample","reElement","reModifier","blockCandidates1","className","blockCandidates2","data","getBEMData","classNames","cl","ix","indexOf","startsWith","filter","uniqueClass","block","findBlockName","path","m","prefix","originalClass","match","getBlockName","arrClassNames","_bem","classValue","stringifyValue$1","parseBEM","depth","getBEMDataFromContext","find","visitor","out","createOutputStream","caret","largestIndex","consumePlaceholder$2","peek$2","namePos","afterPos","isTokenStart","isToken","before","after","comment2","enabled","trigger","createWalkState","template","createCommentState","element$1","format","shouldFormat","isSnippet","getIndent","pushNewline","tagName","shouldComment","shouldOutputAttribute","pushSnippet","innerFormat","hasNewline","attrName","lQuote","attrQuote","rQuote","isBooleanAttribute","fieldIx","findIndex","isField$1","trimLeft","adjacentInline","isInlineElement","element$1$1","primary","secondary","isPrimaryAttribute","collectAttributes","shouldFormat$1","beforeName","afterName","replace","beforeAttribute","pushString","booleanValue","glueAttribute","afterAttribute","splitByLines$1","lineLengths","maxLength","valueLength","beforeTextLine","push$1","afterTextLine","formatters","html","haml","indentFormat","slim","pug","parseOpt","parseAbbreviation","fn","reversed","snippet","snippets","snippetAbbr","topNode","resolveSnippets","transform","lookup","attrName2","mergeValue","db","minWordCount","element2","findRepeater","paragraph","syntax","isAllowed","rename","reProperty","opt$1","key","keywords","parsed","parseValue","cssVal","property","dependencies","parse","trim","v","str1","str2","partialMatch","str1Len","str2Len","minLength","j","score","ch1","ch2","acronym","delta","sum","shortHex","isShortHex","toShortHex","toHex","asHex","values","frac","asRGB","num","digits","toFixed","hex","toString","pad","isJSON","_","letter","getSingleNumeric","getQuote","separator2","prevEnd","color","_a","cache","stylesheetSnippets","keys","createSnippet","sort","snippetsSort","cur2","isProperty","nest","convertSnippets","isValueScope","filteredSnippets","s","getSnippetsForScope","gradientFn","cssValue","field$2","resolveGradient","propName","findBestMatch","inlineValue","lastPos","getUnmatchedPart","kw","resolveKeyword","defaultValue","hasField","wrapWithField","reField","inputValue","outputValue2","exec","literal$4","tail","aliases","unitless","minScore","matchedItem","maxScore","scoreMatch","getScoringPart","ref","dep","q","defaultSyntaxes","markup","stylesheet","defaultConfig$1","lang","locale","charset","indentation","newline","output.indent","output.baseIndent","output.newline","output.tagCase","output.attributeCase","output.attributeQuotes","output.format","output.formatLeafNode","output.formatSkip","output.formatForce","output.inlineBreak","output.compactBoolean","output.booleanAttributes","output.reverseAttributes","output.selfClosingStyle","output.field","output.text","comment.enabled","comment.trigger","comment.before","comment.after","bem.enabled","bem.element","bem.modifier","jsx.enabled","stylesheet.keywords","stylesheet.unitless","stylesheet.shortHex","stylesheet.between","stylesheet.after","stylesheet.intUnit","stylesheet.floatUnit","stylesheet.unitAliases","e","x","stylesheet.json","stylesheet.jsonDoubleQuotes","stylesheet.fuzzySearchMinScore","syntaxConfig","parseSnippets","a:blank","a:link","a:mail","a:tel","acr|acronym","basefont","br","frame","hr","bdo","bdo:r","bdo:l","col","link","link:css","link:print","link:favicon","link:mf|link:manifest","link:touch","link:rss","link:atom","link:im|link:import","meta","meta:utf","meta:vp","meta:compat","meta:edge","meta:redirect","meta:kw","meta:desc","script:src","img","img:s|img:srcset","img:z|img:sizes","picture","src|source","src:sc|source:src","src:s|source:srcset","src:t|source:type","src:z|source:sizes","src:m|source:media","src:mt|source:media:type","src:mz|source:media:sizes","src:zt|source:sizes:type","iframe","embed","param","area","area:d","area:c","area:r","area:p","form","form:get","form:post","label","input","inp","input:h|input:hidden","input:t|input:text","input:search","input:email","input:url","input:p|input:password","input:datetime","input:date","input:datetime-local","input:month","input:week","input:time","input:tel","input:number","input:color","input:c|input:checkbox","input:r|input:radio","input:range","input:f|input:file","input:s|input:submit","input:i|input:image","input:b|input:button","input:reset","isindex","select:d|select:disabled","opt|option","textarea","marquee","menu:c|menu:context","menu:t|menu:toolbar","html:xml","keygen","command","btn:s|button:s|button:submit","btn:r|button:r|button:reset","btn:d|button:d|button:disabled","fst:d|fset:d|fieldset:d|fieldset:disabled","bq","fig","figc","pic","ifr","emb","obj","cap","colg","fst","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datag","datal","kg","det","cmd","ri:d|ri:dpr","ri:v|ri:viewport","ri:a|ri:art","ri:t|ri:type","!!!","doc","!|html:5","c","cc:ie","cc:noie","xhtml","xsl","tm|tmatch","tn|tname","call","ap","api","imp","inc","wh|xsl:when","ot","if","par","pare","var","vare","wp","cp","co","for|each","tex","com","msg","fall","nam","pres","strip","proc","choose","@f","@ff","@i|@import","@kf","@m|@media","ac","ai","anim","animdel","animdir","animdur","animfm","animic","animn","animps","animtf","as","bd","bdb","bdbc","bdbi","bdbk","bdbli","bdblrs","bdbri","bdbrrs","bdbs","bdbw","bdc","bdci","bdcl","bdf","bdi","bdl","bdlc","bdlen","bdli","bdls","bdlw","bdr","bdrc","bdri","bdrs","bdrst","bdrw","bds","bdsp","bdt","bdtc","bdti","bdtli","bdtlrs","bdtri","bdtrrs","bdts","bdtw","bdw","bfv","bg","bga","bgbk","bgc","bgcp","bgi","bgo","bgp","bgpx","bgpy","bgr","bgsz","bxsh","bxsz","cm","cnt","coi","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","cor","cps","cur","d","ec","f","fd","fef","fem","femp","fems","ff","fft","ffa","ffv","fl","fs","fsm","fv","fvs","fw","fx","fxb","fxd","fxf","fxg","fxsh","fxw","fsz","fsza","gtc","gtr","gta","gt","gg","gcg","grg","gac","gar","gaf","gd","gc","gcs","gce","gr","grs","gre","ga","h","jc","ji","js","l","lg","lh","lis","lisi","lisp","list","lts","mah","mar","maw","mb","mih","mir","miw","ml","mr","mt","olc","olo","ols","olw","ord","ori","orp","ov","ovs","ovx","ovy","pb","pgba","pgbb","pgbi","pl","pr","pt","qen","qru","rsz","ta","tal","tbl","td","te","th","ti","tj","tov","trf","trfo","trfs","trs","trsde","trsdu","trsp","trstf","tsh","tt","tw","us","va","w","whs","whsc","wid","wm","wob","wos","wow","z","zom","sass","stylus","k","globals","mergedData","typeDefaults","typeOverride","syntaxDefaults","syntaxOverride","sol","peek$1$1","consume$2","bracePairs","isWhiteSpace$3","consumeIdent","consumeAttributeWithUnquotedValue","consumeAttribute","previous","isQuote$2","consumeQuoted","consumeAttributeWithQuotedValue","isCloseBracket$1","isOpenBracket$2","isUnquotedValue","consumeWhile","isIdent","isAlpha$1","isNumber$1","code","specialChars","defaultOptions$1$1","lookAhead","isCloseBrace","offsetPastAutoClosed","backwardScanner","compiledPrefix","consumePair","consumeArray$1","getStartOffset","isOpenBrace","isHtml","isAbbreviation","abbreviation2","location","consumed","resolvedConfig","resolveConfig","css","parse$1$1","stringify$1","parse$1","pairs","{","[","(","pairsEnd","isSpace$1","isQuote$3","isExprString","isQuoted","createOptions","isPrev","lastType","lastName","lastStart","lastEnd","getTagSelectionModel","selectPreviousItem","selectNextItem","tagSrc","valueRange","tokenList","lastCh","valueDelimiter","splitValue","selectPreviousItem$1","selectNextItem$1","isSelfClose$1","allocItem","last$4","skipCSS","cssCtx","attributeValueRange","getCSSContext","inline","styleStart","styleEnd","detectCSSContextFromHTML","embedded","attributeValue$1","scope","reJSXAbbrStart","reWordBound","reStylesheetWordBound","tabStopStart","fromCodePoint","tabStopEnd","pairs$1","idCounter","substr","startOffset","endOffset","isSpace$2","selFrom","selTo","fieldStartIx","fieldEndIx","operation","toRange","replaceRange","selFromPos","posFromIndex","selToPos","setSelection","setCursor","getCursor","indexFromPos","getValue","getRange","isQuoted$1","isQuote$4","constructor","head","anchor","baseClass2","replaceMap","<",">","&","htmlEscape","hasInternalState","xmlSyntaxes","htmlSyntaxes","cssSyntaxes","jsxSyntaxes","markupSyntaxes","stylesheetSyntaxes","docSyntax","isHTML","content","getContent","getHTMLContext","isXML","last$5","attributeValue$2","getEmbeddedStyleSyntax$1","isCSS","getSyntaxType","mode","getMode","info","candidates","nullary","token","priority","parseFloat","isPositiveSign","isNegativeSign","defaultOptions$2","prev","dot","ops1","ops2","expr","expected","consumeNumber$1","number","isOperator$3","isSign","op1","op2","operators2","operands","nOperators","orderTokens","parse$2","nStack","n1","n2","posObj","getEmmetConfig","lineIndent","getIndentation","field$3","handled","getLine","outputOpt","pluginConfig","expandAbbreviation","extractAbbreviation","inward","last$2","res","isSelfClose","balancedInward","allocTag","balancedOutward","balancedInward$1","allocRange","left","releaseRange","balancedOutward$1","isCSS2","isPrevious","selectItemCSS","selectItemHTML","braces","number$1","extract","evaluate","matchedTag","getAttributes","isQuotedString$1","syntaxInfo","getOutputOptions","getMarkupAbbreviationContext$1","getStylesheetAbbreviationContext$1","previewClass","proxy","marker","forcedMarker","getInternalState","getOptions","previewField","allowTracking","tracker","disposeMarker","markText","inclusiveLeft","inclusiveRight","clearWhenEmpty","forced","document","createElement","addWidget","hidePreview","enabledForSyntax","isError","errorSnippet","simple","previewElem","attachPreview","readOnly","lineNumbers","errElement","appendChild","wrapper","getWrapperElement","parentElement","classList","toggle","querySelector","innerHTML","setValue","remove","isJSX","clear","controller","Map","trackers","get","set","getActivationContext","startTracking","stopTracking","params","createTracker","delete","getTracker","unmark","skipRemove","force","storeTracker","lastLength","parsedAbbr","isSimpleMarkupAbbreviation","previewConfig","error2","getStoredTracker","editorLastPos","getLastPost","setLastPos","typingAbbreviation","nextTracker","targetPos","isValidTracker","restoreTracker","getCSSActivationContext","syntaxType","getEmbeddedStyleSyntax","getMarkupAbbreviationContext","outputOptions","isTypingBeforeSelector","getStylesheetAbbreviationContext","first","isEnabled","getModeAt","configuration","syntaxFromPos","isSupported","run","extract$1","showPreview","lastMatch","tags","tagPreview","ed","dataset","innerText","createPreviewWidget","onCursorActivity","getTagMatches","caret2","getCaret","candidate","findTagMatch","unquoted$1","attrString","suffix","generatePreview","shouldDisplayTagPreview","nLen","rangesEqual","onChange","editor2","getTagMarks","cursor","openRange","closeRange","shouldReset","containsPos","updateTag","on","off","getAllMarks","newName","exclude","comparePos","parseError","error$3","skipToEnd","startState","unexpectedCharacter","lastBrace","last$6","eol","getTokenName","getTokenName$1","ident$1","separator","tabKey","somethingSelected","pass","contains","runInTrackerContext","controller2","proxy2","expandAbbreviationWithTab","expand","textRange","listSelections","between","sticky","cmp","getTokenAt","right","betweenTags","sel","sels","nl","getDoc","lineSeparator","nextSels","nextIndent","nextPos","unshift","setSelections","baseClass","getTagContext","wrapRange","inRange","narrowToNonSpace","getWrapRange","getSelection","destLines","getContent$1","panel","createInputPanel","errContainer","updated","evt","stopPropagation","add","keyCode","preventDefault","undo","focus","removeEventListener","onInput","onKeyDown","cancel","submit","update","addEventListener","selRange","getRanges","targetRange","rangeContains","balanceActionInward","balanceActionOutward","last2","balanceCSS","balance","htmlComment","cssComment","selection","getRangeForComment","commentStart","rangeEmpty","removed","getCommentRegions","removeComment","lineRange","commentEnd","endsWith","r1","r2","isSelfClose$2","allocTag$1","getHTMLBlockRange","consumeSeq2","findCSSComment","css2","bodyStart","bodyEnd","match$1","evaluateMath","docSize","curPos","isNewLine","findNewEditPoint","nextRange","nextRanges","numRange","hasDot","isDot","extractNumber","precision","neg","abs","updateNumber","innerRange2","getLineIndent","innerIndent","lineStart","indentRange","log","model","selectItem","findRange","getNext","selections","closing","getChar","createRange","endTag","CM","commands","emmetExpandAbbreviation","expandAbbreviation$1","emmetExpandAbbreviationAll","emmetCaptureAbbreviation","captureAbbreviation","emmetResetAbbreviation","resetAbbreviation","emmetEnterAbbreviationMode","enterAbbreviationMode","emmetInsertLineBreak","insertLineBreak","emmetWrapWithAbbreviation","wrapWithAbbreviation","emmetBalance","balanceAction","emmetBalanceInward","emmetToggleComment","comment$2","emmetEvaluateMath","evaluateMathCommand","emmetGoToNextEditPoint","goToEditPoint","emmetGoToPreviousEditPoint","emmetGoToTagPair","goToTagPair","emmetIncrementNumber1","incrementNumber","emmetIncrementNumber01","emmetIncrementNumber10","emmetDecrementNumber1","emmetDecrementNumber01","emmetDecrementNumber10","emmetRemoveTag","removeTagCommand","emmetSelectNextItem","selectItemCommand","emmetSelectPreviousItem","emmetSplitJoinTag","splitJoinTag","defineOption","undoTracker","pasteTracker","handleChange","onSelectionChange","handleSelectionChange","disposeEditor","initAbbreviationTracker","tagMatch","markTagMatches","defineMode","emmetAbbreviationMode","emmetAbbreviationMode$1","snippetNameMode","defineExtension","extractTracker","displayText","hint","getCompletion","change","origin","lastTracker"],"mappings":"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"}